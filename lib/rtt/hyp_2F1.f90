!============== START HYP_2F1 FILE ====================================
!
! GAMMA_INV DENOTES THE ENTIRE INVERSE OF THE GAMMA FUNCTION.
! F(Z) MEANS 2F1(A,B,C,Z) WITH THE A, B, C AND Z GIVEN AS INPUTS
! IN THE ROUTINE.
!
! ELEMENTARY FUNCTIONS AND STANDARD CONSTANTS
! ARE DEFINED IN THE MODULE.
! SEE N.J.~HIGHAM, ``ACCURACY AND STABILITY OF NUMERICAL ALGORITHMS'',
! SIAM, PHILADELPHIA, 1996 FOR EXPM1 IMPLEMENTATION.
! LOG1P FOLLOWS INSTANTLY.
!
!----------------------------------------------------------------------
MODULE HYP_2F1_MODULE
  !--------------------------------------------------------------------
  IMPLICIT NONE
  INTEGER, PARAMETER :: PR=KIND(1.0D0),IPR=KIND(1)
  REAL(PR)     :: EPS15=1.0D-15
  REAL(PR)     :: ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0,HALF=0.50D0
  REAL(PR)     :: M_PI=3.14159265358979323846D0
  REAL(PR)     :: M_PI_2=1.57079632679489661923D0
  REAL(PR)     :: M_1_PI=0.31830988618379067154D0
CONTAINS
  !
  FUNCTION INF_NORM(Z)
    COMPLEX(PR),INTENT(IN) :: Z
    REAL(PR)  :: INF_NORM
    INF_NORM=MAX(ABS(REAL(Z,PR)),ABS(AIMAG(Z)))
    RETURN
  END FUNCTION INF_NORM
  !
  FUNCTION TANZ(Z)
    COMPLEX(PR),INTENT(IN) :: Z
    COMPLEX(PR) :: TANZ
    TANZ=SIN(Z)/COS(Z)
    RETURN
  END FUNCTION TANZ
  !
  FUNCTION LOG1P(Z)
    COMPLEX(PR),INTENT(IN) :: Z
    REAL(PR) :: X,XP1,LOG1P_X
    REAL(PR) :: Y,YX,YX2,YX2P1,LOG1P_YX2
    REAL(PR) :: RE_LOG1P,IM_LOG1P
    COMPLEX(PR) :: LOG1P
    IF(INF_NORM(Z).LT.ONE) THEN
       X = REAL(Z,PR); XP1 = X+ONE
       IF(XP1.EQ.ONE) THEN
          LOG1P_X = X
       ELSE
          LOG1P_X = LOG(XP1)*X/(XP1-ONE)
       ENDIF
       Y = AIMAG(Z)
       YX = Y/XP1; YX2 = YX*YX; YX2P1 = YX2+ONE
       IF(YX2P1.EQ.ONE) THEN
          LOG1P_YX2 = YX2
       ELSE
          LOG1P_YX2 = LOG(YX2P1)*YX2/(YX2P1-ONE)
       ENDIF
       RE_LOG1P = LOG1P_X + HALF*LOG1P_YX2
       IM_LOG1P = ATAN2(Y,XP1)
       LOG1P = CMPLX(RE_LOG1P,IM_LOG1P,PR)
       RETURN
    ELSE
       LOG1P=LOG(ONE+Z)
       RETURN
    ENDIF
  END FUNCTION LOG1P
  !
  FUNCTION EXPM1(Z)
    COMPLEX(PR),INTENT(IN) :: Z
    REAL(PR) :: X,EXPM1_X,EXP_X,Y,SIN_HALF_Y
    REAL(PR) :: RE_EXPM1,IM_EXPM1
    COMPLEX(PR) :: EXPM1
    IF(INF_NORM(Z).LT.ONE) THEN
       X = REAL(Z,PR); EXP_X = EXP(X)
       Y = AIMAG(Z); SIN_HALF_Y=SIN(HALF*Y)
       IF(EXP_X.EQ.ONE) THEN
          EXPM1_X = X
       ELSE
          EXPM1_X = (EXP_X-ONE)*X/LOG(EXP_X)
       ENDIF
       RE_EXPM1 = EXPM1_X-TWO*EXP_X*SIN_HALF_Y*SIN_HALF_Y
       IM_EXPM1 = EXP_X*SIN(Y)
       EXPM1 = CMPLX(RE_EXPM1,IM_EXPM1,PR)
       RETURN
    ELSE
       EXPM1=EXP(Z)-ONE
       RETURN
    ENDIF
  END FUNCTION EXPM1
  !
END MODULE HYP_2F1_MODULE
!
!----------------------------------------------------------------------
RECURSIVE FUNCTION LOG_GAMMA2(Z) RESULT(RES)
!----------------------------------------------------------------------
! LOGARITHM OF GAMMA[Z] AND GAMMA INVERSE FUNCTION
! ------------------------------------------------
!
! FOR LOG[GAMMA[Z]],IF Z IS NOT FINITE
! OR IS A NEGATIVE INTEGER, THE PROGRAM
! RETURNS AN ERROR MESSAGE AND STOPS.
! THE LANCZOS METHOD IS USED. PRECISION : ~ 1E-15
! THE METHOD WORKS FOR RE[Z]>0.5 .
! IF RE[Z]<=0.5, ONE USES THE FORMULA GAMMA[Z].GAMMA[1-Z]=PI/SIN(PI.Z)
! LOG[SIN(PI.Z)] IS CALCULATED WITH THE KOLBIG METHOD
! (K.S. KOLBIG, COMP. PHYS. COMM., VOL. 4, P.221(1972)):
! IF Z=X+IY AND Y>=0, LOG[SIN(PI.Z)]=LOG[SIN(PI.EPS)]-I.PI.N,
! WITH Z=N+EPS SO 0<=RE[EPS]< 1 AND N INTEGER.
! IF Y>110, LOG[SIN(PI.Z)]=-I.PI.Z+LOG[0.5]+I.PI/2
! NUMERICALLY SO THAT NO OVERFLOW CAN OCCUR.
! IF Z=X+IY AND Y< 0, LOG[GAMMA(Z)]=[LOG[GAMMA(Z*)]]*,
! SO THAT ONE CAN USE THE PREVIOUS FORMULA WITH Z*.
!
! FOR GAMMA INVERSE, LANCZOS METHOD IS ALSO USED
! WITH EULER REFLECTION FORMULA.
! SIN (PI.Z) IS CALCULATED AS SIN (PI.(Z-N))
! TO AVOID INACCURACY WITH Z = N + EPS
! WITH N INTEGER AND |EPS| AS SMALL AS POSSIBLE.
!
!
! VARIABLES:
! ----------
! X,Y: RE[Z], IM[Z]
! LOG_SQRT_2PI,LOG_PI : LOG[SQRT(2.PI)], LOG(PI).
! SUM : RATIONAL FUNCTION IN THE LANCZOS METHOD
! LOG_GAMMA_Z : LOG[GAMMA(Z)] VALUE.
! C : TABLE CONTAINING THE FIFTEEN COEFFICIENTS IN THE EXPANSION
! USED IN THE LANCZOS METHOD.
! EPS,N : Z=N+EPS SO 0<=RE[EPS]< 1 AND N INTEGER FOR LOG[GAMMA].
!         Z=N+EPS AND N INTEGER
!         SO |EPS| IS AS SMALL AS POSSIBLE FOR GAMMA_INV.
! LOG_CONST : LOG[0.5]+I.PI/2
! G : COEFFICIENT USED IN THE LANCZOS FORMULA. IT IS HERE 607/128.
! Z,Z_M_0P5,Z_P_G_M0P5,ZM1 : ARGUMENT OF THE GAMMA FUNCTION,
! Z-0.5, Z-0.5+G, Z-1
! RES: RETURNED VALUE
!----------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: Z
  INTEGER(IPR) :: N,I
  REAL(PR)     :: X,Y,LOG_SQRT_2PI,G,LOG_PI,M_LN2,C(0:14)
  COMPLEX(PR)  :: GAMMA_SUM,Z_M_0P5,Z_P_G_M0P5,ZM1
  COMPLEX(PR)  :: LOG_CONST,I_PI,EPS,LOG_SIN_PI_Z,RES
  !
  M_LN2=0.69314718055994530942D0; X=REAL(Z,PR); Y=AIMAG(Z)
  IF((Z.EQ.NINT(X)).AND.(X.LE.ZERO)) &
       STOP 'Z IS NEGATIVE INTEGER IN LOG_GAMMA2'
  IF(X.GE.HALF) THEN
     LOG_SQRT_2PI=0.91893853320467274177D0; G=4.7421875D0
     Z_M_0P5=Z-HALF; Z_P_G_M0P5=Z_M_0P5+G; ZM1=Z-ONE
     C=(/ 0.99999999999999709182D0,57.156235665862923517D0,       &
          -59.597960355475491248D0,  14.136097974741747174D0,     &
          -0.49191381609762019978D0, 0.33994649984811888699D-4,   &
          0.46523628927048575665D-4, -0.98374475304879564677D-4,  &
          0.15808870322491248884D-3, -0.21026444172410488319D-3,  &
          0.21743961811521264320D-3, -0.16431810653676389022D-3,  &
          0.84418223983852743293D-4, -0.26190838401581408670D-4,  &
          0.36899182659531622704D-5 /)

     GAMMA_SUM=C(0)
     DO I=1,14
        GAMMA_SUM=GAMMA_SUM+C(I)/(ZM1+I)
     ENDDO
     RES=LOG_SQRT_2PI+LOG(GAMMA_SUM)+Z_M_0P5*LOG(Z_P_G_M0P5) &
          -Z_P_G_M0P5
     RETURN
  ELSE IF(Y.GE.ZERO) THEN
     IF(X.LT.NINT(X)) THEN
        N=NINT(X)-1
     ELSE
        N=NINT(X)
     ENDIF
     LOG_PI=1.1447298858494002D0
     LOG_CONST=CMPLX(-M_LN2,M_PI_2,PR); I_PI=CMPLX(ZERO,M_PI,PR)
     EPS=Z-N
     IF(Y.GT.110.0D0) THEN
        LOG_SIN_PI_Z=-I_PI*Z+LOG_CONST
     ELSE
        LOG_SIN_PI_Z=LOG(SIN(M_PI*EPS))-I_PI*N
     ENDIF
     RES=LOG_PI-LOG_SIN_PI_Z-LOG_GAMMA2(ONE-Z);
     RETURN
  ELSE
     RES=CONJG(LOG_GAMMA2(CONJG(Z)))
     RETURN
  ENDIF
END FUNCTION LOG_GAMMA2
!
!----------------------------------------------------------------------
! INVERSE OF THE GAMMA FUNCTION [1/GAMMA](Z)
! ------------------------------------------
! IT IS CALCULATED WITH THE LANCZOS METHOD FOR RE[Z] >= 0.5
! AND IS PRECISE UP TO 10^{-15}.
! IF RE[Z] <= 0.5, ONE USES THE FORMULA
! GAMMA[Z].GAMMA[1-Z] = PI/SIN (PI.Z).
! SIN (PI.Z) IS CALCULATED AS SIN (PI.(Z-N)) TO AVOID INACCURACY,
! WITH Z = N + EPS WITH N INTEGER AND |EPS| AS SMALL AS POSSIBLE.
!
! VARIABLES
! ---------
! Z : ARGUMENT OF THE FUNCTION
! X: RE[Z]
! EPS,N : Z = N + EPS WITH N INTEGER AND |EPS| AS SMALL AS POSSIBLE.
! RES: RETURNED VALUE
!----------------------------------------------------------------------
RECURSIVE FUNCTION GAMMA_INV(Z) RESULT(RES)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: Z
  INTEGER(IPR) :: N,I
  REAL(PR)     :: X,LOG_SQRT_2PI,G,C(0:14)
  COMPLEX(PR)  :: RES,GAMMA_SUM,Z_M_0P5,Z_P_G_M0P5,ZM1,EPS
  !
  X=REAL(Z,PR)
  IF(X.GE.HALF) THEN
     LOG_SQRT_2PI=0.91893853320467274177D0; G=4.7421875D0
     Z_M_0P5=Z-HALF; Z_P_G_M0P5=Z_M_0P5+G; ZM1=Z-ONE
     C=(/ 0.99999999999999709182D0,57.156235665862923517D0,       &
          -59.597960355475491248D0,  14.136097974741747174D0,     &
          -0.49191381609762019978D0, 0.33994649984811888699D-4,   &
          0.46523628927048575665D-4, -0.98374475304879564677D-4,  &
          0.15808870322491248884D-3, -0.21026444172410488319D-3,  &
          0.21743961811521264320D-3, -0.16431810653676389022D-3,  &
          0.84418223983852743293D-4, -0.26190838401581408670D-4,  &
          0.36899182659531622704D-5 /)

     GAMMA_SUM=C(0)
     DO I=1,14
        GAMMA_SUM=GAMMA_SUM+C(I)/(ZM1+I);
     ENDDO
     RES=EXP(Z_P_G_M0P5-Z_M_0P5*LOG(Z_P_G_M0P5)-LOG_SQRT_2PI) &
          /GAMMA_SUM
     RETURN
  ELSE
     X=REAL(Z,PR); N=NINT(X)
     EPS=Z-N
     IF(MOD(N,2).EQ.0) THEN
        RES=SIN(M_PI*EPS)*M_1_PI/GAMMA_INV (ONE-Z)
        RETURN
     ELSE
        RES=-SIN(M_PI*EPS)*M_1_PI/GAMMA_INV (ONE-Z)
        RETURN
     ENDIF
  ENDIF
END FUNCTION GAMMA_INV
!----------------------------------------------------------------------
!
! CALCULATION OF H(Z,EPS) = [GAMMA(Z+EPS)/GAMMA(Z) - 1]/EPS, WITH E AND
! ---------------------------------------------------------------------
! Z COMPLEX SO Z,Z+EPS ARE NOT NEGATIVE INTEGERS AND 0 <= |EPS|OO < 0.1
! ---------------------------------------------------------------------
! THE FUNCTION H(Z,EPS) = [GAMMA(Z+EPS)/GAMMA(Z) - 1]/E IS CALCULATED
! HERE WITH THE LANCZOS METHOD.
! FOR THE LANCZOS METHOD, THE GAMMA PARAMETER, DENOTED AS G,
! IS 4.7421875 AND ONE USES A SUM OF 15 NUMBERS WITH THE TABLE C[15],
! SO THAT IT IS PRECISE UP TO MACHINE ACCURACY.
! THE H(Z,EPS) FUNCTION IS USED IN FORMULAS OCCURING IN1-Z AND 1/Z
! TRANSFORMATIONS (SEE COMP. PHYS. COMM. PAPER).
!
! ONE MUST HAVE Z AND Z+EPS NOT NEGATIVE INTEGERS AS OTHERWISE
! IT IS CLEARLY NOT DEFINED.
! AS THIS FUNCTION IS MEANT TO BE PRECISE FOR SMALL |EPS|OO,
! ONE HAS TO HAVE 0 <= |EPS|OO < 0.1 .
! INDEED, A DIRECT IMPLEMENTATION OF H(Z,EPS) WITH GAMMA_INV OR
! LOG_GAMMA FOR |EPS|OO >= 0.1 IS NUMERICALLY STABLE.
! THE RETURNED FUNCTION HAS FULL NUMERICAL ACCURACY
! EVEN IF |EPS|OO IS VERY SMALL.
!
! EPS NOT EQUAL TO ZERO
! ---------------------
! IF RE(Z) >= 0.5 OR RE(Z+EPS) >= 0.5, ONE CLEARLY HAS RE(Z) > 0.4
! AND RE(Z+EPS) > 0.4,
! SO THAT THE LANCZOS SUMMATION CAN BE USED FOR BOTH GAMMA(Z)
! AND GAMMA(Z+EPS).
! ONE THEN HAS:
! LOG[GAMMA(Z+EPS)/GAMMA(Z)] =
! (Z-0.5) LOG1P[EPS/(Z+G-0.5)] + EPS LOG(Z+G-0.5+EPS) - EPS
! + LOG1P[-EPS \SUM_{I=1}^{14} C[I]/((Z-1+I)(Z-1+I+EPS))
! / (C[0] + \SUM_{I=1}^{14} C[I]/(Z-1+I))]
! H(Z,EPS) = EXPM1[LOG[GAMMA(Z+EPS)/GAMMA(Z)]]/EPS .
!
! IF RE(Z) < 0.5 AND RE(Z+EPS) < 0.5,
! EULER REFLECTION FORMULA IS USED FOR BOTH GAMMA(Z) AND GAMMA(Z+EPS).
! ONE THEN HAS:
! H(Z+EPS,-EPS) = [COS(PI.EPS) + SIN(PI.EPS)/TAN(PI(Z-N))].H(1-Z,-EPS)
! + (2/EPS).SIN^2(EPS.PI/2) - SIN(PI.EPS)/(EPS.TAN(PI.(Z-N)))
! H(1-Z,-EPS) IS CALCULATED WITH THE LANCZOS SUMMATION
! AS RE(1-Z) >= 0.5 AND RE(1-Z-EPS) >= 0.5 .
! Z-N IS USED IN TAN(PI.Z) INSTEAD OF Z TO AVOID INACCURACIES
! DUE THE FINITE NUMBER OF DIGITS OF PI.
! H(Z,EPS) = H(Z+EPS,-EPS)/(1 - EPS.H(Z+EPS,-EPS))
! PROVIDES THE FINAL RESULT.
!
! EPS EQUAL TO ZERO
! -----------------
! IT IS OBTAINED WITH THE PREVIOUS CASE AND EPS -> 0 :
! IF RE(Z) >= 0.5, ONE HAS:
! H(Z,EPS) = (Z-0.5)/(Z+G-0.5) + LOG(Z+G-0.5) - 1 -
! \SUM_{I=1}^{14} C[I]/((Z-1+I)^2)/(C[0]+\SUM_{I=1}^{14} C[I]/(Z-1+I))
!
! IF RE(Z) < 0.5, ONE HAS:
! H(Z,0) = H(1-Z,0) - PI/TAN(PI.(Z-N))
!
! VARIABLES
! ---------
! Z,EPS: INPUT VARIABLES OF THE FUNCTION H(Z,EPS)
! G,C[15]: DOUBLE AND TABLE OF 15 DOUBLES DEFINING THE LANCZOS SUM
! SO THAT IT PROVIDES THE GAMMA FUNCTION
! PRECISE UP TO MACHINE ACCURACY.
! EPS_PZ,Z_M_0P5,Z_PG_M0P5,EPS_PZ_PG_M0P5,ZM1,ZM1_P_EPS:
! Z+EPS,Z-0.5,Z+G-0.5,Z+EPS+G-0.5,Z-1,Z-1+EPS
! X,EPS_PX: REAL PARTS OF Z AND Z+EPS.
! N,M: CLOSEST INTEGER OT THE REAL PART OF Z, SAME FOR Z+EPS.
! SUM_NUM,SUM_DEN: \SUM_{I=1}^{14} C[I]/((Z-1+I)(Z-1+I+EPS))
! AND (C[0] + \SUM_{I=1}^{14} C[I]/(Z-1+I)).
! THEY APPEAR RESPECTIVELY AS NUMERATOR AND DENOMINATOR IN FORMULAS.
! PI_EPS,TERM,T1_EPS_Z: PI.EPS, SIN (PI.EPS)/TAN(PI.(Z-N)),
! [COS(PI.EPS) + SIN(PI.EPS)/TAN(PI(Z-N))].H(1-Z,-EPS)
! SIN_PI_2_EPS,T2_EPS_Z,T_EPS_Z: SIN^2(EPS.PI/2),
! (2/EPS).SIN^2(EPS.PI/2) - SIN(PI.EPS)/(EPS.TAN(PI.(Z-N))),
! H(Z+EPS,-EPS)
! RES: RETURNED VALUE
!----------------------------------------------------------------------
RECURSIVE FUNCTION GAMMA_RATIO_DIFF_SMALL_EPS(Z,EPS) RESULT(RES)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: Z,EPS
  INTEGER(IPR) :: N,M,I
  REAL(PR)     :: G,X,EPS_PX,C(0:14)
  COMPLEX(PR)  :: RES,SUM_NUM,SUM_DEN
  COMPLEX(PR)  :: EPS_PZ,Z_M_0P5,Z_PG_M0P5,EPS_PZ_PG_M0P5,ZM1
  COMPLEX(PR)  :: CI_ZM1_PI_INV,PI_EPS,TT,T1_EPS_Z,SIN_PI_2_EPS
  COMPLEX(PR)  :: ZM1_P_EPS,T2_EPS_Z,T_EPS_Z
  !
  G=4.74218750D0
  IF(INF_NORM(EPS).GT.0.1D0) &
       STOP 'ONE MUST HAVE |EPS|< 0.1 IN GAMMA_RATIO_DIFF_SMALL_EPS'
  EPS_PZ=Z+EPS; Z_M_0P5=Z-HALF; Z_PG_M0P5=Z_M_0P5+G
  EPS_PZ_PG_M0P5=Z_PG_M0P5+EPS; ZM1=Z-ONE; ZM1_P_EPS=ZM1+EPS
  X=REAL(Z,PR); EPS_PX=REAL(EPS_PZ,PR); N=NINT(X); M=NINT(EPS_PX)
  IF((Z.EQ.N).AND.(N.LE.0)) THEN
     STOP 'Z IS NEGATIVE INTEGER IN GAMMA_RATIO_DIFF_SMALL_EPS'
  ENDIF
  IF((EPS_PZ.EQ.M).AND.(M.LE.0)) THEN
     STOP 'Z+EPS IS NEGATIVE INTEGER IN GAMMA_RATIO_DIFF_SMALL_EPS'
  ENDIF
  C=(/ 0.99999999999999709182D0,57.156235665862923517D0,     &
       -59.597960355475491248D0,14.136097974741747174D0,     &
       -0.49191381609762019978D0,0.33994649984811888699D-4,  &
       0.46523628927048575665D-4,-0.98374475304879564677D-4, &
       0.15808870322491248884D-3,-0.21026444172410488319D-3, &
       0.21743961811521264320D-3,-0.16431810653676389022D-3, &
       0.84418223983852743293D-4,-0.26190838401581408670D-4, &
       0.36899182659531622704D-5 /)
  IF((X.GE.HALF).OR.(EPS_PX.GE.HALF)) THEN
     SUM_NUM=ZERO;SUM_DEN=C(0)
     DO I=1,14
        CI_ZM1_PI_INV=C(I)/(ZM1+I)
        SUM_NUM=SUM_NUM+CI_ZM1_PI_INV/(ZM1_P_EPS+I)
        SUM_DEN=SUM_DEN+CI_ZM1_PI_INV
     ENDDO
     IF(EPS.NE.ZERO) THEN
        RES=EXPM1(Z_M_0P5*LOG1P(EPS/Z_PG_M0P5) &
             +EPS*LOG(EPS_PZ_PG_M0P5)-EPS+LOG1P(-EPS*SUM_NUM/SUM_DEN))&
             /EPS
        RETURN
     ELSE
        RES=Z_M_0P5/Z_PG_M0P5 &
             +LOG(EPS_PZ_PG_M0P5)-ONE-SUM_NUM/SUM_DEN
        RETURN
     ENDIF
  ELSE
     IF(EPS.NE.ZERO) THEN
        PI_EPS=M_PI*EPS
        TT=SIN(PI_EPS)/TANZ(M_PI*(Z-N))
        T1_EPS_Z=(COS(PI_EPS)+TT)*&
             GAMMA_RATIO_DIFF_SMALL_EPS(ONE-Z,-EPS)
        SIN_PI_2_EPS=SIN(M_PI_2*EPS)
        T2_EPS_Z=(TWO*SIN_PI_2_EPS*SIN_PI_2_EPS-TT)/EPS
        T_EPS_Z=T1_EPS_Z+T2_EPS_Z
        RES=(T_EPS_Z/(ONE-EPS*T_EPS_Z))
        RETURN
     ELSE
        RES=GAMMA_RATIO_DIFF_SMALL_EPS(ONE-Z,-EPS) &
             -M_PI/TANZ(M_PI*(Z-N))
        RETURN
     ENDIF
  ENDIF
END FUNCTION GAMMA_RATIO_DIFF_SMALL_EPS
!
!----------------------------------------------------------------------
! CALCULATION OF G(Z,EPS) = [GAMMA_INV(Z) - GAMMA_INV(Z+EPS)]/EPS
! ---------------------------------------------------------------
! WITH E AND Z COMPLEX
!---------------------
! THE G(Z,EPS) FUNCTION IS USED IN FORMULAS OCCURING IN 1-Z
! AND 1/Z TRANSFORMATIONS (SEE COMP. PHYS. COMM. PAPER).
! SEVERAL CASE HAVE TO BE CONSIDERED FOR ITS EVALUATION.
! EPS IS CONSIDERED EQUAL TO ZERO
! IF Z+EPS AND Z ARE EQUAL NUMERICALLY.
!
! |EPS|OO > 0.1
! -------------
! A DIRECT EVALUATION WITH THE VALUES GAMMA_INV(Z)
! AND GAMMA_INV(Z+EPS) IS STABLE AND RETURNED.
!
! |EPS|OO <= 0.1 WITH Z+EPS AND Z NUMERICALLY DIFFERENT
! -----------------------------------------------------
! IF Z IS A NEGATIVE INTEGER, Z+EPS IS NOT,
! SO THAT G(Z,EPS) = -GAMMA_INV(Z+EPS)/EPS,
! FOR WHICH A DIRECT EVALUATION IS PRECISE AND RETURNED.
! IF Z+EPS IS A NEGATIVE INTEGER, Z IS NOT,
! SO THAT G(Z,EPS) = GAMMA_INV(Z)/EPS,
! FOR WHICH A DIRECT EVALUATION IS PRECISE AND RETURNED.
! IF BOTH OF THEM ARE NOT NEGATIVE INTEGERS,
! ONE LOOKS FOR THE ONE OF Z AND Z+EPS
! WHICH IS THE CLOSEST TO A NEGATIVE INTEGER.
! IF IT IS Z, ONE RETURNS H(Z,EPS).GAMMA_INV(Z+EPS).
! IF IT IS Z+EPS, ONE RETURNS H(Z+EPS,-EPS).GAMMA_INV(Z).
! BOTH VALUES ARE EQUAL, SO THAT ONE CHOOSES THE ONE
! WHICH MAKES THE GAMMA RATIO GAMMA(Z+EPS)/GAMMA(Z)
! IN H(Z,EPS) THE SMALLEST IN MODULUS.
!
! Z+EPS AND Z NUMERICALLY EQUAL
! -----------------------------
! IF Z IS NEGATIVE INTEGER, G(Z,0) = (-1)^(N+1) N!,
! WHERE Z = -N, N INTEGER, WHICH IS RETURNED.
! IF Z IS NOT NEGATIVE INTEGER, ONE RETURNS H(Z,EPS).GAMMA_INV(Z+EPS)
!
! VARIABLES
! ---------
! Z,EPS: INPUT VARIABLES OF THE FUNCTION G(Z,EPS)
! EPS_PZ,X,EPS_PX: Z+EPS,REAL PARTS OF Z AND Z+EPS.
! N,M: CLOSEST INTEGER OT THE REAL PART OF Z, SAME FOR Z+EPS.
! FACT,K: (-1)^(N+1) N!, RETURNED WHEN Z = -N, N INTEGER
! AND Z AND Z+EPS IDENTICAL NUMERICALLY (EPS ~ 0).
! IT IS CALCULATED WITH INTEGER INDEX K.
! IS_Z_NEGATIVE_INTEGER,IS_EPS_PZ_NEGATIVE_INTEGER:
! TRUE IF Z IS A NEGATIVE INTEGER, FALSE IF NOT, SAME FOR Z+EPS.
! Z_NEG_INT_DISTANCE, EPS_PZ_NEG_INT_DISTANCE:
! |Z + |N||OO, |Z + EPS + |M||OO.
! IF |Z + |N||OO < |Z + EPS + |M||OO,
! Z IS CLOSER TO THE SET OF NEGATIVE INTEGERS THAN Z+EPS.
! GAMMA_INV(Z+EPS) IS THEN OF MODERATE MODULUS
! IF GAMMA_INV(Z) IS VERY SMALL.
! IF Z ~ N, H(Z,EPS) ~ -1/EPS,
! THAT SO RETURNING
! G(Z,EPS) = H(Z,EPS).GAMMA_INV(Z+EPS) HERE IS PREFERRED.
! SAME FOR |Z + |N||OO > |Z + EPS + |M||OO WITH Z <-> Z+EPS.
!
!----------------------------------------------------------------------
FUNCTION GAMMA_INV_DIFF_EPS(Z,EPS)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: Z,EPS
  INTEGER(IPR) :: M,N,K
  REAL(PR)     :: X,EPS_PX,FACT
  REAL(PR)     :: Z_NEG_INT_DISTANCE
  REAL(PR)     :: EPS_PZ_NEG_INT_DISTANCE
  COMPLEX(PR)  :: GAMMA_INV_DIFF_EPS,EPS_PZ,GAMMA_INV
  COMPLEX(PR)  :: GAMMA_RATIO_DIFF_SMALL_EPS
  LOGICAL      :: IS_Z_NEG_INT,IS_EPS_PZ_NEG_INT

  EPS_PZ=Z+EPS; X=REAL(Z,PR); EPS_PX=REAL(EPS_PZ,PR)
  N=NINT(X); M=NINT(EPS_PX)
  IS_Z_NEG_INT=(Z.EQ.N).AND.(N.LE.0)
  IS_EPS_PZ_NEG_INT=(EPS_PZ.EQ.M).AND.(M.LE.0)
  IF(INF_NORM(EPS).GT.0.10D0) THEN
     GAMMA_INV_DIFF_EPS = (GAMMA_INV (Z) - GAMMA_INV (EPS_PZ))/EPS
     RETURN
  ELSE IF(EPS_PZ.NE.Z) THEN
     IF(IS_Z_NEG_INT) THEN
        GAMMA_INV_DIFF_EPS = (-GAMMA_INV (EPS_PZ)/EPS)
        RETURN
     ELSE IF(IS_EPS_PZ_NEG_INT) THEN
        GAMMA_INV_DIFF_EPS = (GAMMA_INV (Z)/EPS)
        RETURN
     ELSE
        Z_NEG_INT_DISTANCE = INF_NORM (Z + ABS (N))
        EPS_PZ_NEG_INT_DISTANCE = INF_NORM (EPS_PZ + ABS (M))
        IF(Z_NEG_INT_DISTANCE.LT.EPS_PZ_NEG_INT_DISTANCE) THEN
           GAMMA_INV_DIFF_EPS= &
                GAMMA_RATIO_DIFF_SMALL_EPS (Z,EPS)*GAMMA_INV (EPS_PZ)
           RETURN
        ELSE
           GAMMA_INV_DIFF_EPS= &
                GAMMA_RATIO_DIFF_SMALL_EPS (EPS_PZ,-EPS)*GAMMA_INV (Z)
           RETURN
        ENDIF
     ENDIF
  ELSE IF(IS_Z_NEG_INT.AND.IS_EPS_PZ_NEG_INT) THEN
     FACT = -ONE;K=-1
     DO WHILE (K.GE.N)
        FACT=FACT*K
        K=K-1
     ENDDO
     GAMMA_INV_DIFF_EPS = FACT
     RETURN
  ELSE
     GAMMA_INV_DIFF_EPS = &
          GAMMA_RATIO_DIFF_SMALL_EPS (Z,EPS)*GAMMA_INV (EPS_PZ)
     RETURN
  ENDIF
END FUNCTION GAMMA_INV_DIFF_EPS
!----------------------------------------------------------------------
!
! CALCULATION OF GAMMA_INV(1-M-EPS)/EPS OF THE A(Z) POLYNOMIAL IN 1-Z
! -------------------------------------------------------------------
! AND 1/Z TRANSFORMATIONS
! -----------------------
! THIS VALUE OCCURS IN A(Z) IN 1-Z AND 1/Z TRANSFORMATIONS
! (SEE COMP. PHYS. COMM. PAPER) FOR M > 0.
! BOTH CASES OF 1-M-EPS NUMERICALLY NEGATIVE INTEGER
! OR NOT HAVE TO BE CONSIDERED
!
! 1-EPS-M AND 1-M NUMERICALLY DIFFERENT
! -------------------------------------
! ONE RETURNS GAMMA_INV(1-M-EPS)/EPS DIRECTLY
! AS ITS VALUE IS ACCURATE.
! TO CALCULATE GAMMA_INV(1-M-EPS),
! ONE USES THE VALUE GAMMA_INV(1-EPS),
! NEEDED IN CONSIDERED TRANSFORMATIONS,
! AND ONE USES THE EQUALITY
! GAMMA_INV(1-M-EPS) = GAMMA_INV(1-EPS) \PROD_{I=1}^{M} (1-EPS-I)
! FOR M > 0.
! IT IS TRIVIALLY DEMONSTRATED
! FROM THE EQUALITY GAMMA(X+1) = X.GAMMA(X).
! ONE GAMMA FUNCTION EVALUATION IS REMOVED THIS WAY
! FROM THE CALCULATION.
!
! 1-EPS-M AND 1-M NUMERICALLY EQUAL
! ---------------------------------
! THIS IMPLIES THAT 1-M-EPS IS NEGATIVE INTEGER NUMERICALLY.
! HERE, EPS~0, SO THAT ONE RETURNS THE LIMIT OF GAMMA_INV(1-M-EPS)/EPS
! FOR EPS -> 0, WHICH IS (-1)^M (M-1)!
!
! VARIABLES
! ---------
! M,EPS: VARIABLE INPUTS OF THE FUNCTION
! (M,EPS) -> GAMMA_INV(1-M-EPS)/EPS
! GAMMA_INV_ONE_MEPS: GAMMA_INV(1-EPS),
! PREVIOUSLY CALCULATED AND HERE RECYCLED
! TO QUICKLY CALCULATE GAMMA_INV(1-M-EPS).
! ONE_MEPS: 1-EPS
!----------------------------------------------------------------------
FUNCTION A_SUM_INIT(M,EPS,GAMMA_INV_ONE_MEPS)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  INTEGER(IPR),INTENT(IN) :: M
  COMPLEX(PR),INTENT(IN) :: EPS,GAMMA_INV_ONE_MEPS
  INTEGER(IPR) :: N,I
  REAL(PR)     :: FACT
  COMPLEX(PR)  :: A_SUM_INIT,ONE_MEPS
  COMPLEX(PR)  :: GAMMA_INV_ONE_MEPS_MM
  !
  ONE_MEPS = ONE - EPS
  IF(ONE_MEPS-M.NE.1-M) THEN
     GAMMA_INV_ONE_MEPS_MM = GAMMA_INV_ONE_MEPS
     DO I=1,M
        GAMMA_INV_ONE_MEPS_MM = GAMMA_INV_ONE_MEPS_MM*(ONE_MEPS-I)
     ENDDO
     A_SUM_INIT=GAMMA_INV_ONE_MEPS_MM/EPS
     RETURN
  ELSE
     FACT=ONE
     DO N=2,M-1
        FACT=FACT*N
     ENDDO
     IF(MOD(M,2).EQ.0) THEN
        A_SUM_INIT=FACT
     ELSE
        A_SUM_INIT=-FACT
     ENDIF
     RETURN
  ENDIF
END FUNCTION A_SUM_INIT
!
!----------------------------------------------------------------------
! CALCULATION OF THE LOG OF GAMMA_INV(1-M-EPS)/EPS
! ------------------------------------------------
! SEE PREVIOUS FUNCTION.
! IT IS USED IN CASE GAMMA_INV(1-M-EPS)/EPS MIGHT OVERFLOW.
!
! VARIABLES
! ---------
! M,EPS: VARIABLE INPUTS OF THE FUNCTION
! (M,EPS) -> LOG[GAMMA_INV(1-M-EPS)/EPS]
! ONE_MEPS_MM: 1-EPS-M
! I_PI: I.PI
! LOG_FACT: LOGARITHM OF (-1)^M (M-1)!,
! HERE DEFINED AS LOG((M-1)!) + I.PI IF M IS ODD.
!----------------------------------------------------------------------
FUNCTION LOG_A_SUM_INIT(M,EPS)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  INTEGER(IPR),INTENT(IN) :: M
  COMPLEX(PR),INTENT(IN) :: EPS
  INTEGER(IPR) :: N
  REAL(PR)     :: LOG_FACT
  COMPLEX(PR)  :: ONE_MEPS_MM,LOG_A_SUM_INIT,LOG_GAMMA2
  !
  ONE_MEPS_MM=ONE-EPS-M
  IF(ONE_MEPS_MM.NE.1-M) THEN
     LOG_A_SUM_INIT=(-LOG_GAMMA2(ONE_MEPS_MM) - LOG(EPS))
     RETURN
  ELSE
     LOG_FACT=ZERO
     DO N=2,M-1
        LOG_FACT=LOG_FACT + LOG(DBLE(N))
     ENDDO
     IF(MOD(M,2).EQ.0) THEN
        LOG_A_SUM_INIT=LOG_FACT
     ELSE
        LOG_A_SUM_INIT=CMPLX(LOG_FACT,M_PI,PR)
     ENDIF
     RETURN
  ENDIF
END FUNCTION LOG_A_SUM_INIT
!----------------------------------------------------------------------
! CALCULATION OF THE FIRST TERM OF THE B(Z) POWER SERIES
! ------------------------------------------------------
! IN THE 1-Z TRANSFORMATION, DIVIDED BY (1-Z)^M
! ----------------------------------------------
! IN THE 1-Z TRANSFORMATION,
! THE POWER SERIES B(Z) = \SUM_{N=0}^{+OO} \BETA_N (1-Z)^N OCCURS
! (SEE COMP. PHYS. COMM. PAPER).
! THE FIRST TERM \BETA_0, DIVIDED BY (1-Z)^M, IS CALCULATED HERE.
! M IS THE CLOSEST INTEGER TO RE(C-A-B) >= 0 AND EPS = C-A-B-M.
!
! ONE HAS TO CONSIDER |EPS|OO > 0.1 AND |EPS|OO <= 0.1,
! WHERE 1-M-EPS AND 1-M CAN BE DIFFERENT OR EQUAL NUMERICALLY,
! LEADING TO SOME CHANGES IN THIS LAST CASE.
!
! |EPS|OO > 0.1
! -------------
! ONE HAS \BETA_0/(1-Z)^M = [(A)_M (B)_M GAMMA_INV(1-EPS)
! GAMMA_INV(A+M+EPS) GAMMA_INV(B+M+EPS) GAMMA_INV(M+1)
! - (1-Z)^EPS GAMMA_INV(A) GAMMA_INV(B) GAMMA_INV(1+M+EPS)]
! [GAMMA(C)/EPS], STABLE IN THIS REGIME FOR A DIRECT EVALUATION.
!
! THE VALUES OF GAMMA(C), GAMMA_INV(A+M+EPS)
! AND GAMMA_INV(B+M+EPS) WERE ALREADY CALCULATED AND RECYCLED HERE.
! GAMMA_INV(M+1) IS CALCULATED AS 1/(M!).
!
! GAMMA_INV(1+M+EPS) IS CALCULATED FROM GAMMA_INV(1-EPS),
! USING THE EQUALITIES:
! GAMMA_INV(1-M-EPS) = GAMMA_INV(1-EPS) \PROD_{I=1}^{M} (1-EPS-I),
! WHERE THE PRODUCT IS 1 BY DEFINITION IF M = 0,
! GAMMA_INV(1+M+EPS) = (-1)^M SIN (PI.EPS)
! /[PI.(EPS+M).GAMMA_INV(1-M-EPS)]
! FROM EULER REFLECTION FORMULA, GAMMA(X+1) = X.GAMMA(X) EQUALITY,
! AND M+EPS NO ZERO.
! THIS SCHEME IS MUCH FASTER THAN
! TO RECALCULATE GAMMA_INV(1+M+EPS) DIRECTLY.
!
! |EPS|OO <= 0.1
! --------------
! THE \BETA_0/(1-Z)^M EXPRESSION IS REWRITTEN
! SO THAT IT CONTAINS NO INSTABILITIES:
! \BETA_0/(1-Z)^M = GAMMA_INV(A+M+EPS) GAMMA_INV(B+M+EPS)
! [(G(1,-EPS) GAMMA_INV(M+1) + G(M+1,EPS))
! - GAMMA_INV(1+M+EPS) (G(A+M,EPS) GAMMA_INV(B+M+EPS)
! + G(B+M,EPS) GAMMA_INV(A+M))
! - E(LOG(1-Z),EPS) GAMMA_INV(A+M) GAMMA_INV(B+M) GAMMA_INV(1+M+EPS)]
! (A)_M (B)_M GAMMA(C)
!
! E(LOG(1-Z),EPS) IS [(1-Z)^EPS - 1]/EPS
! IF 1-M-EPS AND 1-M ARE DIFFERENT NUMERICALLY,
! AND LOG(1-Z) OTHERWISE (EPS ~ 0).
! IF 1-M-EPS AND 1-M ARE EQUAL NUMERICALLY,
! GAMMA_INV(1+M+EPS) IS NUMERICALLY EQUAL TO GAMMA_INV(1+M),
! ALREADY CALCULATED AS 1/(M!).
! SEE |EPS|OO > 0.1 CASE FOR DATA RECYCLING OF OTHER VALUES
! OR FOR 1-M-EPS AND 1-M DIFFERENT NUMERICALLY.
!
!----------------------------------------------------------------------
! VARIABLES
! ---------
! A,B,C,ONE_MINUS_Z: A,B,C AND 1-Z PARAMETERS AND ARGUMENTS
! OF THE 2F1(A,B,C,Z) FUNCTION.
! M,EPS: CLOSEST INTEGER TO C-A-B, WITH RE(C-A-B) >= 0
! AND EPS = C-A-B-M
! GAMMA_C,GAMMA_INV_ONE_MEPS,GAMMA_INV_EPS_PA_PM, GAMMA_INV_EPS_PB_PM:
! RECYCLED VALUES OF GAMMA(C), GAMMA_INV(1-EPS),
! GAMMA_INV(A+M+EPS) AND GAMMA_INV(B+M+EPS).
! INF_NORM_EPS,PHASE,A_PM,B_PM,ONE_MEPS,PI_EPS,PI_EPS_PM:
! |EPS|OO,(-1)^M,A+M,B+M,1-EPS,PI.EPS,PI.(EPS+M)
! GAMMA_INV_ONE_MEPS_MM,GAMMA_INV_EPS_PM_P1:
! GAMMA_INV(1-M-EPS) AND GAMMA_INV(1+M+EPS)
! CALCULATED WITH THE RECYCLING SCHEME.
! PROD1: (A)_M (B)_M GAMMA_INV(1-EPS) GAMMA_INV(A+M+EPS)
! X GAMMA_INV(B+M+EPS) GAMMA_INV(M+1) IN |EPS|OO > 0.1 CASE.
! PROD2: (1-Z)^EPS GAMMA_INV(A) GAMMA_INV(B) GAMMA_INV(1+M+EPS)
! IN |EPS|OO > 0.1 CASE.
! GAMMA_INV_MP1,PROD_AB: GAMMA_INV(M+1) CALCULATED AS 1/(M!)
! AND (A)_M (B)_M IN |EPS|OO <= 0.1 CASE.
! IS_EPS_NON_ZERO: TRUE IF 1-M-EPS AND 1-M ARE DIFFERENT NUMERICALLY,
! FALSE IF NOT.
! GAMMA_INV_A_PM,GAMMA_INV_B_PM,Z_TERM: GAMMA_INV(A+M),GAMMA_INV(B+M),
! E(EPS,LOG(1-Z))
! PROD1: GAMMA_INV(A+M+EPS) GAMMA_INV(B+M+EPS)
! X [(G(1,-EPS) GAMMA_INV(M+1) + G(M+1,EPS)) IN |EPS|OO <= 0.1 CASE.
! PROD2: GAMMA_INV(1+M+EPS) (G(A+M,EPS) GAMMA_INV(B+M+EPS)
! + G(B+M,EPS) GAMMA_INV(A+M))
! PROD3: E(EPS,LOG(1-Z)) GAMMA_INV(A+M) GAMMA_INV(B+M)
! GAMMA_INV(1+M+EPS)
! RES: RETURNED \BETA_0/(1-Z)^M VALUE IN ALL CASES.
!----------------------------------------------------------------------
FUNCTION B_SUM_INIT_PS_ONE(A,B,GAMMA_C,GAMMA_INV_ONE_MEPS, &
     GAMMA_INV_EPS_PA_PM,GAMMA_INV_EPS_PB_PM,MZP1,M,EPS)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  INTEGER(IPR),INTENT(IN) :: M
  COMPLEX(PR),INTENT(IN) :: A,B,GAMMA_C,GAMMA_INV_ONE_MEPS, &
       GAMMA_INV_EPS_PA_PM,GAMMA_INV_EPS_PB_PM,MZP1,EPS
  INTEGER(IPR) :: M_M1,N,I,PHASE
  REAL(PR)     :: INF_NORM_EPS,GAMMA_INV_MP1
  COMPLEX(PR)  :: A_PM,B_SUM_INIT_PS_ONE,PI_EPS,GAMMA_INV_ONE_MEPS_MM
  COMPLEX(PR)  :: B_PM,TMP1,TMP2
  COMPLEX(PR)  :: Z_TERM,PROD1,PROD2,PROD3,ONE_MEPS,PI_EPS_PM
  COMPLEX(PR)  :: GAMMA_INV_A_PM,PROD_AB,GAMMA_INV,GAMMA_INV_B_PM
  COMPLEX(PR)  :: GAMMA_INV_DIFF_EPS,GAMMA_INV_EPS_PM_P1
  !
  INF_NORM_EPS=INF_NORM(EPS); M_M1=M-1; A_PM=A+M; B_PM=B+M
  ONE_MEPS=ONE-EPS; PI_EPS=M_PI*EPS; PI_EPS_PM = M_PI*(EPS+M)
  IF(MOD(M,2).EQ.0) THEN
     PHASE = 1
  ELSE
     PHASE = -1
  ENDIF
  GAMMA_INV_ONE_MEPS_MM = GAMMA_INV_ONE_MEPS
  DO I=1,M
     GAMMA_INV_ONE_MEPS_MM = GAMMA_INV_ONE_MEPS_MM*(ONE_MEPS - I)
  ENDDO
  IF(INF_NORM_EPS.GT.0.10D0) THEN
     GAMMA_INV_EPS_PM_P1 = PHASE*SIN(PI_EPS) &
          /(PI_EPS_PM*GAMMA_INV_ONE_MEPS_MM)
     PROD1=GAMMA_INV_ONE_MEPS*GAMMA_INV_EPS_PA_PM*GAMMA_INV_EPS_PB_PM
     DO N=0,M_M1
        PROD1=PROD1*(A+N)*(B+N)/(N+ONE)
     ENDDO
     PROD2=GAMMA_INV(A)*GAMMA_INV(B)*GAMMA_INV_EPS_PM_P1*(MZP1**EPS)
     B_SUM_INIT_PS_ONE=GAMMA_C*(PROD1-PROD2)/EPS
     RETURN
  ELSE
     GAMMA_INV_MP1=ONE;PROD_AB=ONE
     DO N=0,M_M1
        GAMMA_INV_MP1 = GAMMA_INV_MP1/(N+ONE)
        PROD_AB = PROD_AB*(A+N)*(B+N)
     ENDDO
     IF(ONE_MEPS-M.NE.1-M) THEN
        Z_TERM=EXPM1(EPS*LOG(MZP1))/EPS
        GAMMA_INV_EPS_PM_P1 = PHASE*SIN(PI_EPS) &
             /(PI_EPS_PM*GAMMA_INV_ONE_MEPS_MM)
     ELSE
        Z_TERM=LOG(MZP1)
        GAMMA_INV_EPS_PM_P1 = GAMMA_INV_MP1
     ENDIF
     GAMMA_INV_A_PM=GAMMA_INV(A_PM);GAMMA_INV_B_PM=GAMMA_INV(B_PM)
     TMP1=ONE; TMP2=M+1;
     PROD1 = GAMMA_INV_EPS_PA_PM*GAMMA_INV_EPS_PB_PM    &
          *(GAMMA_INV_MP1*GAMMA_INV_DIFF_EPS(TMP1,-EPS) &
          +GAMMA_INV_DIFF_EPS(TMP2,EPS))
     PROD2 = GAMMA_INV_EPS_PM_P1 &
          *(GAMMA_INV_EPS_PB_PM*GAMMA_INV_DIFF_EPS(A_PM,EPS) &
          +GAMMA_INV_A_PM*GAMMA_INV_DIFF_EPS (B_PM,EPS))
     PROD3 = GAMMA_INV_A_PM*GAMMA_INV_B_PM*GAMMA_INV_EPS_PM_P1*Z_TERM
     B_SUM_INIT_PS_ONE=GAMMA_C*PROD_AB*(PROD1-PROD2-PROD3)
     RETURN
  ENDIF
END FUNCTION B_SUM_INIT_PS_ONE
!
!----------------------------------------------------------------------
! CALCULATION OF THE FIRST TERM OF THE B(Z) POWER SERIES
! ------------------------------------------------------
! IN THE 1/Z TRANSFORMATION, DIVIDED BY Z^{-M}
!---------------------------------------------
! IN THE 1/Z TRANSFORMATION, THE POWER SERIES
! B(Z) = \SUM_{N=0}^{+OO} \BETA_N Z^{-N} OCCURS
! (SEE COMP. PHYS. COMM. PAPER).
! THE FIRST TERM \BETA_0, DIVIDED BY Z^{-M}, IS CALCULATED HERE.
! M IS THE CLOSEST INTEGER TO RE(B-A) >= 0 AND EPS = B-A-M.
!
! ONE HAS TO CONSIDER |EPS|OO > 0.1 AND |EPS|OO <= 0.1,
! WHERE 1-M-EPS AND 1-M CAN BE DIFFERENT OR EQUAL NUMERICALLY,
! LEADING TO SOME CHANGES IN THIS LAST CASE.
!
! |EPS|OO > 0.1
! -------------
! ONE HAS \BETA_0/Z^{-M} = [(A)_M (1-C+A)_M GAMMA_INV(1-EPS)
! GAMMA_INV(A+M+EPS) GAMMA_INV(C-A) GAMMA_INV(M+1)
! - (-Z)^{-EPS} (1-C+A+EPS)_M GAMMA_INV(A) GAMMA_INV(C-A-EPS)
! GAMMA_INV(1+M+EPS)].[GAMMA(C)/EPS],
! STABLE IN THIS REGIME FOR A DIRECT EVALUATION.
!
! THE VALUES OF GAMMA(C), GAMMA_INV(C-A) AND GAMMA_INV(A+M+EPS)
! WERE ALREADY CALCULATED AND RECYCLED HERE.
! GAMMA_INV(M+1) IS CALCULATED AS 1/(M!).
! GAMMA_INV(1+M+EPS) IS CALCULATED FROM GAMMA_INV(1-EPS)
! AS IN THE 1-Z TRANSFORMATION ROUTINE.
!
! |EPS|OO <= 0.1
! --------------
! THE \BETA_0/Z^{-M} EXPRESSION IS REWRITTEN
! SO THAT IT CONTAINS NO INSTABILITIES:
! \BETA_0/Z^{-M} = [((1-C+A+EPS)_M G(1,-EPS) - P(M,EPS,1-C+A)
! GAMMA_INV(1-EPS)) GAMMA_INV(C-A) GAMMA_INV(A+M+EPS) GAMMA_INV(M+1)
! + (1-C+A+EPS)_M [G(M+1,EPS) GAMMA_INV(C-A) GAMMA_INV(A+M+EPS)
! - G(A+M,EPS) GAMMA_INV(C-A) GAMMA_INV(M+1+EPS)]
! - (G(C-A,-EPS) - E(LOG(-Z),-EPS)) GAMMA_INV(M+1+EPS)
! GAMMA_INV(A+M)]] (A)_M GAMMA(C)
!
! DEFINITIONS AND METHOD ARE THE SAME
! AS IN THE 1-Z TRANSFORMATION ROUTINE, EXCEPT FOR P(M,EPS,1-C+A).
! P(M,EPS,S) = [(S+EPS)_M - (S)_M]/EPS
! FOR EPS NON ZERO AND HAS A LIMIT FOR EPS -> 0.
! LET N0 BE THE CLOSEST INTEGER TO -RE(S) FOR S COMPLEX.
! A STABLE FORMULA AVAILABLE FOR EPS -> 0 FOR P(M,EPS,S) IS:
! P(M,EPS,S) = (S)_M E(\SUM_{N=0}^{M-1} L(1/(S+N),EPS),EPS)
! IF N0 IS NOT IN [0:M-1],
! P(M,EPS,S) = \PROD_{N=0, N NOT EQUAL TO N0}^{M-1} (S+EPS+N)
! + (S)_M E(\SUM_{N=0, N NOT EQUAL TO N0}^{M-1} L(1/(S+N),EPS),EPS)
! IF N0 IS IN [0:M-1].
! L(S,EPS) IS LOG1P(S EPS)/EPS IF EPS IS NOT ZERO,
! AND L(S,0) = S.
! THIS EXPRESSION IS USED IN THE CODE.
!
! VARIABLES
! ---------
! A,B,C,Z: A,B,C AND Z PARAMETERS
! AND ARGUMENTS OF THE 2F1(A,B,C,Z) FUNCTION.
! M,EPS: CLOSEST INTEGER TO B-A, WITH RE(B-A) >= 0 AND EPS = B-A-M.
! GAMMA_C,GAMMA_INV_CMA,GAMMA_INV_ONE_MEPS,GAMMA_INV_EPS_PA_PM:
! RECYCLED VALUES OF GAMMA(C), GAMMA_INV(C-A), GAMMA_INV(1-EPS)
! AND GAMMA_INV(A+M+EPS).
! INF_NORM_EPS,PHASE,CMA,A_MC_P1,A_MC_P1_PM,CMA_EPS,EPS_PA_MC_P1,A_PM:
! |EPS|OO,(-1)^M,C-A,1-C+A+M,C-A-EPS,1-C+A+EPS,A+M
! GAMMA_INV_CMA_MEPS,ONE_MEPS,PI_EPS,PI_EPS_PM:
! GAMMA_INV(C-A-EPS),1-EPS,PI.EPS,PI.(EPS+M)
! GAMMA_INV_ONE_MEPS_MM,GAMMA_INV_EPS_PM_P1: GAMMA_INV(1-M-EPS)
! AND GAMMA_INV(1+M+EPS) CALCULATED WITH THE RECYCLING SCHEME.
! PROD1: (A)_M (1-C+A)_M GAMMA_INV(1-EPS) GAMMA_INV(A+M+EPS)
! X GAMMA_INV(C-A) GAMMA_INV(M+1) IN |EPS|OO > 0.1 CASE.
! PROD2: (-Z)^{-EPS} (1-C+A+EPS)_M GAMMA_INV(A)
! X GAMMA_INV(C-A-EPS) GAMMA_INV(1+M+EPS) IN |EPS|OO > 0.1 CASE.
! N0: CLOSEST INTEGER TO -RE(1-C+A)
! IS_N0_HERE: TRUE IS N0 BELONGS TO [0:M-1], FALSE IF NOT.
! IS_EPS_NON_ZERO: TRUE IF 1-M-EPS AND 1-M ARE DIFFERENT NUMERICALLY,
! FALSE IF NOT.
! GAMMA_INV_MP1,PROD_A,PROD_A_MC_P1:
! GAMMA_INV(M+1) CALCULATED AS 1/(M!),
! (A)_M AND (1-C+A)_M IN |EPS|OO <= 0.1 CASE.
! PROD_EPS_PA_MC_P1_N0:
! \PROD_{N=0, N NOT EQUAL TO N0}^{M-1} (1-C+A+EPS+N)
! IF N0 BELONGS TO [0:M-1], 0.0 IF NOT, IN |EPS|OO <= 0.1 CASE.
! PROD_EPS_PA_MC_P1: (1-C+A+EPS)_M IN |EPS|OO <= 0.1 CASE.
! SUM: \SUM_{N=0, N NOT EQUAL TO N0}^{M-1} L(1/(S+N),EPS) IF 1-M-EPS
! AND 1-M ARE DIFFERENT NUMERICALLY,
! \SUM_{N=0, N NOT EQUAL TO N0}^{M-1} 1/(S+N) IF NOT.
! A_PN,A_MC_P1_PN,EPS_PA_MC_P1_PN: A+N,1-C+A+N,1-C+A+EPS+N VALUES
! USED IN (A)_M, (1-C+A)_M AND (1-C+A+EPS)_M EVALUATIONS.
! SUM_TERM,PROD_DIFF_EPS,Z_TERM:
! E(\SUM_{N=0, N NOT EQUAL TO N0}^{M-1} L(1/(S+N),EPS),EPS),
! P(M,EPS,1-C+A), -E(-EPS,LOG(-Z))
! GAMMA_INV_A_PM,GAMMA_PROD1: GAMMA_INV(A+M),
! GAMMA_INV(C-A).GAMMA_INV(A+M+EPS)
! PROD1: ((1-C+A+EPS)_M G(1,-EPS)
! - P(M,EPS,1-C+A) GAMMA_INV(1-EPS)) GAMMA_INV(C-A)
! X GAMMA_INV(A+M+EPS) GAMMA_INV(M+1)
! PROD_2A: GAMMA_INV(C-A).GAMMA_INV(A+M+EPS).G(M+1,EPS)
! PROD_2B: G(A+M,EPS) GAMMA_INV(C-A) GAMMA_INV(M+1+EPS)
! PROD_2C: (G(C-A,-EPS)
! - E(LOG(-Z),-EPS)) GAMMA_INV(M+1+EPS) GAMMA_INV(A+M)
! PROD2: (1-C+A+EPS)_M [G(M+1,EPS) GAMMA_INV(C-A) GAMMA_INV(A+M+EPS)
! - G(A+M,EPS) GAMMA_INV(C-A) GAMMA_INV(M+1+EPS)]
! - (G(C-A,-EPS) - E(LOG(-Z),-EPS))
! X GAMMA_INV(M+1+EPS) GAMMA_INV(A+M)]]
! RES: RETURNED \BETA_0/Z^{-M} VALUE IN ALL CASES.
!----------------------------------------------------------------------
FUNCTION B_SUM_INIT_PS_INFINITY(A,C,GAMMA_C,GAMMA_INV_CMA, &
     GAMMA_INV_ONE_MEPS,GAMMA_INV_EPS_PA_PM,Z,M,EPS)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  INTEGER(IPR),INTENT(IN) :: M
  COMPLEX(PR),INTENT(IN) :: A,C,GAMMA_C,GAMMA_INV_CMA,Z,EPS
  COMPLEX(PR),INTENT(IN) :: GAMMA_INV_ONE_MEPS,GAMMA_INV_EPS_PA_PM
  INTEGER(IPR) :: M_M1,I,N,N0,PHASE
  LOGICAL      :: IS_N0_HERE,IS_EPS_NON_ZERO
  REAL(PR)     :: INF_NORM_EPS,NP1,GAMMA_INV_MP1
  COMPLEX(PR)  :: B_SUM_INIT_PS_INFINITY,GAMMA_INV,TMP1
  COMPLEX(PR)  :: CMA,A_MC_P1,A_MC_P1_PM,CMA_MEPS,EPS_PA_MC_P1,A_PM
  COMPLEX(PR)  :: GAMMA_INV_EPS_PM_P1,GAMMA_INV_CMA_MEPS,PI_EPS
  COMPLEX(PR)  :: PROD1,PROD2,A_PN,A_MC_P1_PN,ONE_MEPS
  COMPLEX(PR)  :: PROD_A,PROD_A_MC_P1,PROD_EPS_PA_MC_P1_N0,PI_EPS_PM
  COMPLEX(PR)  :: PROD_EPS_PA_MC_P1,SUM_N0,Z_TERM,SUM_TERM
  COMPLEX(PR)  :: PROD_DIFF_EPS,GAMMA_INV_A_PM,GAMMA_PROD1
  COMPLEX(PR)  :: PROD_2A,PROD_2B,PROD_2C,GAMMA_INV_DIFF_EPS
  COMPLEX(PR)  :: EPS_PA_MC_P1_PN,GAMMA_INV_ONE_MEPS_MM
  !
  INF_NORM_EPS=INF_NORM(EPS); CMA=C-A; A_MC_P1=A-C+ONE
  A_MC_P1_PM=A_MC_P1+M; CMA_MEPS=CMA-EPS; EPS_PA_MC_P1=EPS+A_MC_P1
  A_PM=A+M; M_M1=M-1; ONE_MEPS=ONE-EPS; PI_EPS=M_PI*EPS
  PI_EPS_PM=M_PI*(EPS+M); GAMMA_INV_CMA_MEPS=GAMMA_INV(CMA_MEPS)
  IF(MOD(M,2).EQ.0) THEN
     PHASE = 1
  ELSE
     PHASE = -1
  ENDIF
  GAMMA_INV_ONE_MEPS_MM = GAMMA_INV_ONE_MEPS
  DO I=1,M
     GAMMA_INV_ONE_MEPS_MM = GAMMA_INV_ONE_MEPS_MM*(ONE_MEPS - I)
  ENDDO
  IF(INF_NORM_EPS.GT.0.1D0) THEN
     GAMMA_INV_EPS_PM_P1 = PHASE*SIN(PI_EPS) &
          /(PI_EPS_PM*GAMMA_INV_ONE_MEPS_MM)
     PROD1 = GAMMA_INV_CMA*GAMMA_INV_EPS_PA_PM*GAMMA_INV_ONE_MEPS
     PROD2 = GAMMA_INV(A)*GAMMA_INV_CMA_MEPS*GAMMA_INV_EPS_PM_P1 &
          *((-Z)**(-EPS))
     DO N=0,M_M1
        A_PN=A+N; A_MC_P1_PN=A_MC_P1+N
        EPS_PA_MC_P1_PN=EPS+A_MC_P1_PN;NP1=N+ONE
        PROD1 = PROD1*A_PN*A_MC_P1_PN/NP1
        PROD2 = PROD2*EPS_PA_MC_P1_PN
     ENDDO
     B_SUM_INIT_PS_INFINITY = GAMMA_C*(PROD1-PROD2)/EPS
     RETURN
  ELSE
     N0=-NINT(REAL(A_MC_P1,PR))
     IS_EPS_NON_ZERO=ONE_MEPS-M.NE.1-M
     IS_N0_HERE=(N0.GE.0).AND.(N0.LT.M)
     GAMMA_INV_MP1=ONE; PROD_A=ONE; PROD_A_MC_P1=ONE
     PROD_EPS_PA_MC_P1=ONE; SUM_N0=ZERO
     IF(IS_N0_HERE) THEN
        PROD_EPS_PA_MC_P1_N0 = ONE
     ELSE
        PROD_EPS_PA_MC_P1_N0 = ZERO
     ENDIF
     DO N=0,M_M1
        A_PN=A+N; A_MC_P1_PN=A_MC_P1+N
        EPS_PA_MC_P1_PN=EPS+A_MC_P1_PN; NP1=N+ONE
        PROD_A = PROD_A*A_PN
        PROD_A_MC_P1 = PROD_A_MC_P1*A_MC_P1_PN
        PROD_EPS_PA_MC_P1 = PROD_EPS_PA_MC_P1*EPS_PA_MC_P1_PN
        GAMMA_INV_MP1 = GAMMA_INV_MP1/NP1
        IF(N.NE.N0) THEN
           IF(IS_N0_HERE) THEN
              PROD_EPS_PA_MC_P1_N0=PROD_EPS_PA_MC_P1_N0 &
                   *EPS_PA_MC_P1_PN
           ENDIF
           IF(IS_EPS_NON_ZERO) THEN
              SUM_N0 = SUM_N0 + LOG1P(EPS/A_MC_P1_PN)
           ELSE
              SUM_N0 = SUM_N0 + ONE/A_MC_P1_PN
           ENDIF
        ENDIF
     ENDDO
     IF(IS_EPS_NON_ZERO) THEN
        GAMMA_INV_EPS_PM_P1 = PHASE*SIN(PI_EPS) &
             /(PI_EPS_PM*GAMMA_INV_ONE_MEPS_MM)
        SUM_TERM = EXPM1(SUM_N0)/EPS
        Z_TERM = EXPM1(-EPS*LOG(-Z))/EPS
     ELSE
        GAMMA_INV_EPS_PM_P1 = GAMMA_INV_MP1
        SUM_TERM = SUM_N0
        Z_TERM = -LOG(-Z)
     ENDIF
     PROD_DIFF_EPS = PROD_EPS_PA_MC_P1_N0 + PROD_A_MC_P1*SUM_TERM
     GAMMA_INV_A_PM = GAMMA_INV(A_PM)
     GAMMA_PROD1=GAMMA_INV_CMA*GAMMA_INV_EPS_PA_PM
     TMP1=ONE
     PROD1 = GAMMA_PROD1*GAMMA_INV_MP1*(GAMMA_INV_DIFF_EPS(TMP1,-EPS) &
          *PROD_EPS_PA_MC_P1 - GAMMA_INV_ONE_MEPS*PROD_DIFF_EPS)
     TMP1=M+1
     PROD_2A = GAMMA_PROD1*GAMMA_INV_DIFF_EPS(TMP1,EPS)
     PROD_2B = GAMMA_INV_CMA*GAMMA_INV_EPS_PM_P1  &
          *GAMMA_INV_DIFF_EPS(A_PM,EPS)
     PROD_2C = GAMMA_INV_EPS_PM_P1*GAMMA_INV_A_PM &
          *(GAMMA_INV_DIFF_EPS(CMA,-EPS) + GAMMA_INV_CMA_MEPS*Z_TERM)
     PROD2 = PROD_EPS_PA_MC_P1*(PROD_2A - PROD_2B - PROD_2C)
     B_SUM_INIT_PS_INFINITY = GAMMA_C*PROD_A*(PROD1+PROD2)
     RETURN
  ENDIF
END FUNCTION B_SUM_INIT_PS_INFINITY
!
!----------------------------------------------------------------------
! CALCULATION OF THE DERIVATIVE OF THE POLYNOMIAL P(X)
! ----------------------------------------------------
! TESTING POWER SERIES CONVERGENCE
! --------------------------------
! P(X) = |Z(A+X)(B+X)|^2 - |(C+X)(X+1)|^2
!      = \SUM_{I=0}^{4} C[I] X^{I}, FOR |Z| < 1.
! IT IS POSITIVE WHEN THE POWER SERIES TERM MODULUS INCREASES
! AND NEGATIVE WHEN IT DECREASES,
! SO THAT ITS DERIVATIVE PROVIDES INFORMATION ON ITS CONVERGENCE
! (SEE COMP. PHYS. COMM. PAPER).
! ITS DERIVATIVE COMPONENTS CV_POLY_DER_TAB[I] = (I+1) C[I+1]
! FOR I IN [0:3]
! SO THAT P'(X) = \SUM_{I=0}^{3} CV_POLY_DER_TAB[I] X^{I}
! ARE CALCULATED.
!
! VARIABLES:
! ----------
! A,B,C,Z: A,B,C AND Z PARAMETERS AND ARGUMENTS
! OF THE 2F1(A,B,C,Z) FUNCTION.
! CV_POLY_DER_TAB[3]: TABLE OF FOUR DOUBLES
! CONTAINING THE P'(X) COMPONENTS.
! MOD_A2,MOD_B2,MOD_C2,MOD_Z2,R_A,RE_B,RE_C: |A|^2, |B|^2, |C|^2,
! |Z|^2, RE(A), RE(B), RE(C), WITH WHICH P(X) CAN BE EXPRESSED.
!----------------------------------------------------------------------
SUBROUTINE CV_POLY_DER_TAB_CALC(A,B,C,Z,CV_POLY_DER_TAB)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,Z
  REAL(PR),INTENT(OUT) :: CV_POLY_DER_TAB(0:3)
  REAL(PR)     :: MOD_A2,MOD_B2,MOD_C2,MOD_Z2
  REAL(PR)     :: RE_A,RE_B,RE_C,IM_A,IM_B,IM_C,RE_Z,IM_Z
  !
  RE_A=REAL(A,PR); IM_A=AIMAG(A); MOD_A2=RE_A*RE_A+IM_A*IM_A
  RE_B=REAL(B,PR); IM_B=AIMAG(B); MOD_B2=RE_B*RE_B+IM_B*IM_B
  RE_C=REAL(C,PR); IM_C=AIMAG(C); MOD_C2=RE_C*RE_C+IM_C*IM_C
  RE_Z=REAL(Z,PR); IM_Z=AIMAG(Z); MOD_Z2=RE_Z*RE_Z+IM_Z*IM_Z
  CV_POLY_DER_TAB(0)=TWO*((RE_A*MOD_B2+RE_B*MOD_A2)*MOD_Z2-RE_C-MOD_C2)
  CV_POLY_DER_TAB(1)=TWO*((MOD_A2+MOD_B2+4.0D0*RE_A*RE_B)*MOD_Z2 &
       -ONE-4.0D0*RE_C-MOD_C2)
  CV_POLY_DER_TAB(2)=6.0D0*((RE_A+RE_B)*MOD_Z2-RE_C-ONE)
  CV_POLY_DER_TAB(3)=4.0D0*(MOD_Z2-ONE)
END SUBROUTINE CV_POLY_DER_TAB_CALC
!
!----------------------------------------------------------------------
! CALCULATION OF THE DERIVATIVE OF THE POLYNOMIAL P(X)
! ----------------------------------------------------
! TESTING POWER SERIES CONVERGENCE AT ONE X VALUE
! -----------------------------------------------
! P'(X) IS CALCULATED FOR A REAL X.
! SEE P'(X) COMPONENTS CALCULATION ROUTINE FOR DEFINITIONS.
!----------------------------------------------------------------------
FUNCTION CV_POLY_DER_CALC(CV_POLY_DER_TAB,X)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  REAL(PR),INTENT(IN) :: X
  REAL(PR),INTENT(IN) :: CV_POLY_DER_TAB(0:3)
  REAL(PR) :: CV_POLY_DER_CALC
  !
  CV_POLY_DER_CALC=CV_POLY_DER_TAB(0)+X*(CV_POLY_DER_TAB(1) &
       +X*(CV_POLY_DER_TAB(2)+X*CV_POLY_DER_TAB(3)))
  RETURN
END FUNCTION CV_POLY_DER_CALC
!
!----------------------------------------------------------------------
! CALCULATION OF AN INTEGER AFTER WHICH FALSE CONVERGENCE CANNOT OCCUR
! --------------------------------------------------------------------
! SEE CV_POLY_DER_TAB_CALC ROUTINE FOR DEFINITIONS.
! IF P'(X) < 0 AND P''(X) < 0 FOR X > XC, IT WILL BE SO FOR ALL X > XC
! AS P(X) -> -OO FOR X -> +OO
! AND P(X) CAN HAVE AT MOST ONE MAXIMUM FOR X > XC.
! IT MEANS THAT THE 2F1 POWER SERIES TERM MODULUS WILL INCREASE
! OR DECREASE TO 0 FOR N > NC,
! WITH NC THE SMALLEST POSITIVE INTEGER LARGER THAN XC.
!
! IF P'(X) = C0 + C1.X + C2.X^2 + C3.X^3,
! THE DISCRIMINANT OF P''(X) IS DELTA = C2^2 - 3 C1 C3.
!
! IF DELTA > 0, P''(X) HAS TWO DIFFERENT REAL ROOTS
! AND ITS LARGEST ROOT IS -(C2 + SQRT(DELTA))/(3 C3),
! BECAUSE C3 = 4(|Z|^2 - 1) < 0.
! ONE CAN TAKE XC = -(C2 + SQRT(DELTA))/(3 C3)
! AND ONE RETURNS ITS ASSOCIATED NC INTEGER.
!
! IF DELTA <= 0, P''(X) HAS AT MOST ONE REAL ROOT,
! SO THAT P'(X) HAS ONLY ONE ROOT AND THEN P(X) ONLY ONE MAXIMUM.
! IN THIS CASE, ONE CAN CHOOSE XC = NC = 0, WHICH IS RETURNED.
!
! VARIABLES
! ---------
! CV_POLY_DER_TAB: TABLE OF FOUR DOUBLES
! CONTAINING THE P'(X) COEFFICIENTS
! C1,C2,THREE_C3: CV_POLY_DER_TAB[1], CV_POLY_DER_TAB[2]
! AND 3.0*CV_POLY_DER_TAB[3], SO THAT P''(X) = C1 + 2.C2.X + THREE_C3.X^2
! DELTA: DISCRIMINANT OF P''(X), EQUAL TO C2^2 - 3 C1 C3.
! LARGEST_ROOT: IF DELTA > 0,
! P''(X) LARGEST REAL ROOT EQUAL TO -(C2 + SQRT(DELTA))/(3 C3).
!----------------------------------------------------------------------
FUNCTION MIN_N_CALC(CV_POLY_DER_TAB)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  REAL(PR),INTENT(IN) :: CV_POLY_DER_TAB(0:3)
  INTEGER(IPR) :: MIN_N_CALC
  REAL(PR)     :: C1,C2,THREE_C3,DELTA,LARGEST_ROOT
  !
  C1=CV_POLY_DER_TAB(1); C2=CV_POLY_DER_TAB(2)
  THREE_C3=3.0D0*CV_POLY_DER_TAB(3); DELTA = C2*C2 - THREE_C3*C1
  IF(DELTA.LE.ZERO) THEN
     MIN_N_CALC = 0
     RETURN
  ELSE
     LARGEST_ROOT = -(C2 + SQRT (DELTA))/THREE_C3
     MIN_N_CALC = MAX(CEILING(LARGEST_ROOT),0)
     RETURN
  ENDIF
END FUNCTION MIN_N_CALC
!
!----------------------------------------------------------------------
! CALCULATION OF THE 2F1 POWER SERIES CONVERGING FOR |Z| < 1
! ----------------------------------------------------------
! ONE HAS 2F1(A,B,C,Z)
! = \SUM_{N = 0}^{+OO} (A)_N (B)_N / ((C)_N N!) Z^N,
! SO THAT 2F1(A,B,C,Z) = \SUM_{N = 0}^{+OO} T[N] Z^N,
! WITH T[0] = 1 AND T[N+1] = (A+N)(B+N)/((C+N)(N+1)) T[N] FOR N >= 0.
! IF A OR B ARE NEGATIVE INTEGERS,
! F(Z) IS A POLYNOMIAL OF DEGREE -A OR -B, EVALUATED DIRECTLY.
! IF NOT, ONE USES THE TEST OF CONVERGENCE |T[N] Z^N|OO < 1E-15
! TO TRUNCATE THE SERIES AFTER IT WAS CHECKED
! THAT FALSE CONVERGENCE CANNOT OCCUR.
! VARIABLES:
! ----------
! A,B,C,Z: A,B,C AND Z PARAMETERS AND ARGUMENTS
! OF THE 2F1(A,B,C,Z) FUNCTION. ONE MUST HAVE HERE |Z| < 1.
! TERM,SUM: TERM OF THE 2F1 POWER SERIES EQUAL TO T[N] Z^N,
! TRUNCATED SUM AT GIVEN N OF THE 2F1 POWER SERIES.
! NA,NB: ABSOLUTE VALUES OF THE CLOSEST INTEGERS TO RE(A) AND RE(B).
! A = -NA OR B = -NB MEANS ONE IS IN THE POLYNOMIAL CASE.
! CV_POLY_DER_TAB: COEFFICIENTS OF THE DERIVATIVE
! OF THE POLYNOMIAL P(X) = |Z(A+X)(B+X)|^2 - |(C+X)(X+1)|^2
! MIN_N: SMALLEST INTEGER AFTER WHICH FALSE CONVERGENCE CANNOT OCCUR.
! IT IS CALCULATED IN MIN_N_CALC.
! POSSIBLE_FALSE_CV: ALWAYS TRUE IF N < MIN_N.
! IF N >= MIN_N, IT IS TRUE IF P'(N) > 0.
! IF N >= MIN_N AND P'(N) < 0,
! IT BECOMES FALSE AND REMAINS AS SUCH FOR THE REST OF THE CALCULATION.
! ONE CAN THEN CHECK IF |T[N] Z^N|OO < 1E-15 TO TRUNCATE THE SERIES.
!----------------------------------------------------------------------
FUNCTION HYP_PS_ZERO(A,B,C,Z)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,Z
  INTEGER(IPR) :: N,NA,NB,MIN_N,MIN_N_CALC
  COMPLEX(PR)  :: HYP_PS_ZERO,TERM
  LOGICAL :: POSSIBLE_FALSE_CV
  REAL(PR) :: CV_POLY_DER_TAB(0:3)
  REAL(PR) :: CV_POLY_DER_CALC
  !
  NA = ABS(NINT(REAL(A,PR)))
  NB = ABS(NINT(REAL(B,PR)))
  TERM=ONE; HYP_PS_ZERO=ONE
  IF(A.EQ.(-NA)) THEN
     DO N=0,NA-1
        TERM = TERM*Z*(A+N)*(B+N)/((N+ONE)*(C+N))
        HYP_PS_ZERO = HYP_PS_ZERO + TERM
     ENDDO
     RETURN
  ELSE IF(B.EQ.(-NB)) THEN
     DO N=0,NB-1
        TERM = TERM*Z*(A+N)*(B+N)/((N+ONE)*(C+N))
        HYP_PS_ZERO = HYP_PS_ZERO + TERM
     ENDDO
     RETURN
  ELSE
     CALL CV_POLY_DER_TAB_CALC(A,B,C,Z,CV_POLY_DER_TAB)
     POSSIBLE_FALSE_CV=.TRUE.
     MIN_N=MIN_N_CALC(CV_POLY_DER_TAB);N=0
     DO WHILE(POSSIBLE_FALSE_CV.OR.(INF_NORM(TERM).GT.EPS15))
        TERM = TERM*Z*(A+N)*(B+N)/((N+ONE)*(C+N))
        HYP_PS_ZERO = HYP_PS_ZERO + TERM
        IF(POSSIBLE_FALSE_CV.AND.(N.GT.MIN_N)) THEN
           POSSIBLE_FALSE_CV = &
                (CV_POLY_DER_CALC (CV_POLY_DER_TAB,DBLE(N)).GT.ZERO)
        ENDIF
        N=N+1
     ENDDO
     RETURN
  ENDIF
END FUNCTION HYP_PS_ZERO
!
!----------------------------------------------------------------------
! CALCULATION OF THE 2F1 POWER SERIES
! -----------------------------------
! CONVERGING WITH THE 1-Z TRANSFORMATION
! --------------------------------------
! THE FORMULA FOR F(Z) IN THE 1-Z TRANSFORMATION HOLDS:
! F(Z) = (-1)^M (PI.EPS)/SIN (PI.EPS) [A(Z) + B(Z)]
! FOR EPS NOT EQUAL TO ZERO, F(Z) = (-1)^M [A(Z) + B(Z)] FOR EPS = 0
! WHERE M = |RE(C-A-B)], EPS = C-A-B-M,
! A(Z) = \SUM_{N=0}^{M-1} ALPHA[N] (1-Z)^N,
! B(Z) = \SUM_{N=0}^{+OO} BETA[N] (1-Z)^N, AND:
!
! ALPHA[0] = [GAMMA_INV(1-M-EPS)/EPS] GAMMA_INV(A+M+EPS)
!          X GAMMA_INV(B+M+EPS) GAMMA(C)
! [GAMMA_INV(1-M-EPS)/EPS] IS CALCULATED IN A_SUM_INIT.
! ALPHA[0] IS CALCULATED WITH LOG[GAMMA]
! IF THE PREVIOUS EXPRESSION MIGHT OVERFLOW,
! AND ITS IMAGINARY PART REMOVED IF A, B AND C ARE REAL.
! ALPHA[N+1] = (A+N)(B+N)/[(N+1)(1-M-EPS+N)] ALPHA[N], N IN [0:M-2].
!
! BETA[0] IS DEFINED IN B_SUM_INIT_PS_ONE FUNCTION COMMENTS.
! GAMMA[0] = GAMMA(C) (A)_M (B)_M (1-Z)^M GAMMA_INV(A+M+EPS)
!          X GAMMA_INV(B+M+EPS) GAMMA_INV(M+1) GAMMA_INV(1-EPS)
!
! BETA[N+1] = (A+M+N+EPS)(B+M+N+EPS)/[(M+N+1+EPS)(N+1)] BETA[N]
! + [(A+M+N)(B+M+N)/(M+N+1) - (A+M+N) - (B+M+N) - EPS
! + (A+M+N+EPS)(B+M+N+EPS)/(N+1)]
!             X GAMMA[N]/[(N+M+1+EPS)(N+1+EPS)], N >= 0.
! GAMMA[N+1] = (A+M+N)(B+M+N)/[(M+N+1)(N+1-EPS)] GAMMA[N], N >= 0.
!
! B(Z) CONVERGES <=> |1-Z| < 1
! THE TEST OF CONVERGENCE IS |BETA[N] (1-Z)^N|OO < 1E-15 |BETA[0]|OO
! FOR N LARGE ENOUGH SO THAT FALSE CONVERGENCE CANNOT OCCUR.
!
! VARIABLES
! ---------
! A,B,C,ONE_MINUS_Z: A,B,C PARAMETERS
! AND 1-Z FROM Z ARGUMENT OF 2F1(A,B,C,Z)
! M,PHASE,M_P1,EPS,EPS_PM,EPS_PM_P1,
! A_PM,B_PM,ONE_MEPS,ONE_MEPS_PM:
! |RE(C-A-B)], (-1)^M, M+1, C-A-B-M,
! EPS+M, EPS+M+1, A+M, B+M, 1-EPS, 1-EPS-M
! EPS_PA,EPS_PB,EPS_PA_PM,EPS_PB_PM,PI_EPS,GAMMA_C:
! EPS+A, EPS+B, EPS+A+M, EPS+B+M, PI.EPS, GAMMA(C)
! GAMMA_INV_EPS_PA_PM,GAMMA_INV_EPS_PB_PM,GAMMA_PROD:
! GAMMA_INV(EPS+A+M), GAMMA_INV(EPS+B+M),
! GAMMA(C).GAMMA_INV(EPS+A+M).GAMMA_INV(EPS+B+M)
! GAMMA_INV_ONE_MEPS,A_FIRST_TERM,A_SUM,A_TERM:
! GAMMA_INV(1-EPS), ALPHA[0], A(Z), ALPHA[N] (1-Z)^N
! POW_MZP1_M,B_FIRST_TERM,PROD_B,RATIO: (1-Z)^M, BETA[0],
! (A)_M (B)_M (1-Z)^M, (A+N)(B+N)/(N+1) FOR N IN [0:M-2].
! B_EXTRA_TERM,B_TERM,B_SUM,B_PREC:
! GAMMA[N], BETA[N] (1-Z)^N, B(Z), 1E-15 |BETA[0|OO
! CV_POLY1_DER_TAB,CV_POLY2_DER_TAB: P1'(X) AND P2'(X) COEFFICIENTS
! OF THE POTENTIALS DERIVATIVES OF P1(X) AND P2(X)
! DEFINED IN CV_POLY_DER_TAB_CALC WITH PARAMETERS
! A1 = A, B1 = B, C1 = 1-M-EPS, Z1 = 1-Z
! AND A2 = EPS+B+M, B2 = EPS+A+M,C2 = EPS+M+1, Z2 = 1-Z.
! MIN_N: SMALLEST INTEGER AFTER WHICH FALSE CONVERGENCE CANNOT OCCUR.
! IT IS CALCULATED IN MIN_N_CALC WITH BOTH P1'(X) AND P2'(X),
! SO ONE TAKES THE LARGEST INTEGER COMING FROM BOTH CALCULATIONS.
! POSSIBLE_FALSE_CV: ALWAYS TRUE IF N < MIN_N.
! IF N >= MIN_N, IT IS TRUE IF P1'(N) > 0 OR P2'(N) > 0.
! IF N >= MIN_N AND P1'(N) < 0 AND P2'(N) < 0,
! IT BECOMES FALSE AND REMAINS AS SUCH FOR THE REST OF THE CALCULATION.
! ONE CAN THEN CHECK IF |BETA[N] Z^N|OO < 1E-15 TO TRUNCATE THE SERIES.
! N,N_PM_P1,N_P1,A_PM_PN,B_PM_PN,EPS_PM_P1_PN,N_P1_MEPS,EPS_PA_PM_PN,
! EPS_PB_PM_PN,EPS_PM_PN: INDEX OF POWER SERIES, N+M+1, N+1,
! A+M+N, B+M+N, EPS+M+N+1, N+1-EPS, EPS+A+M+N, EPS+B+M+N, EPS+M+N,
! PROD1,PROD2,PROD3: (EPS+A+M+N)(EPS+B+M+N),
! (EPS+M+1+N)(N+1), (A+M+N)(B+M+N)
!----------------------------------------------------------------------
FUNCTION HYP_PS_ONE(A,B,C,MZP1)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,MZP1
  INTEGER(IPR) :: N,M,PHASE,M_M2,MIN_N,MIN_N_CALC,M_P1
  REAL(PR)     :: B_PREC,N_P1,N_PM_P1,CV_POLY_DER_CALC
  COMPLEX(PR)  :: HYP_PS_ONE,EPS,EPS_PM,EPS_PM_P1,A_PM
  COMPLEX(PR)  :: B_PM,ONE_MEPS_MM,EPS_PA,EPS_PB,PI_EPS,GAMMA_PROD
  COMPLEX(PR)  :: EPS_PA_PM,EPS_PB_PM,GAMMA_INV,B_SUM_INIT_PS_ONE
  COMPLEX(PR)  :: A_SUM_INIT,LOG_A_SUM_INIT,A_SUM,A_TERM,ONE_MEPS
  COMPLEX(PR)  :: B_EXTRA_TERM,B_TERM,B_SUM,GAMMA_C,LOG_GAMMA2,RATIO
  COMPLEX(PR)  :: A_PM_PN,B_PM_PN,EPS_PM_P1_PN,N_P1_MEPS
  COMPLEX(PR)  :: PROD1,PROD2,PROD3
  COMPLEX(PR)  :: EPS_PA_PM_PN,EPS_PB_PM_PN,EPS_PM_PN,PROD_B,POW_MZP1_M
  COMPLEX(PR)  :: GAMMA_INV_EPS_PA_PM,GAMMA_INV_EPS_PB_PM
  COMPLEX(PR)  :: GAMMA_INV_ONE_MEPS
  LOGICAL :: POSSIBLE_FALSE_CV
  REAL(PR) :: CV_POLY1_DER_TAB(0:3),CV_POLY2_DER_TAB(0:3)
  !
  M=NINT(REAL(C-A-B,PR)); M_M2=M-2; M_P1=M+1
  IF(MOD(M,2).EQ.0) THEN
     PHASE=1
  ELSE
     PHASE=-1
  ENDIF
  EPS=C-A-B-M; EPS_PM=EPS+M; EPS_PM_P1=EPS_PM+ONE; A_PM=A+M;B_PM=B+M
  ONE_MEPS=ONE-EPS; ONE_MEPS_MM=ONE_MEPS-M; EPS_PA=EPS+A; EPS_PB=EPS+B
  PI_EPS=M_PI*EPS; EPS_PA_PM=EPS_PA+M; EPS_PB_PM=EPS_PB+M
  GAMMA_C=ONE/GAMMA_INV(C)
  GAMMA_INV_EPS_PA_PM=GAMMA_INV(EPS_PA_PM)
  GAMMA_INV_EPS_PB_PM=GAMMA_INV(EPS_PB_PM)
  GAMMA_PROD=GAMMA_C*GAMMA_INV_EPS_PA_PM*GAMMA_INV_EPS_PB_PM
  GAMMA_INV_ONE_MEPS=GAMMA_INV(ONE_MEPS)
  IF(M.EQ.0) THEN
     A_TERM=ZERO
  ELSE IF(INF_NORM(ONE_MEPS_MM &
       *(LOG(ONE + ABS(ONE_MEPS_MM))-ONE)).LT.300.0D0) THEN
     A_TERM=GAMMA_PROD*A_SUM_INIT(M,EPS,GAMMA_INV_ONE_MEPS)
  ELSE
     A_TERM=EXP(LOG_GAMMA2(C)-LOG_GAMMA2(EPS_PA_PM)&
          -LOG_GAMMA2(EPS_PB_PM)+LOG_A_SUM_INIT(M,EPS))
     IF((AIMAG(A).EQ.ZERO).AND.(AIMAG(B).EQ.ZERO)&
          .AND.(AIMAG(C).EQ.ZERO)) THEN
        A_TERM=REAL(A_TERM,PR)
     ENDIF
  ENDIF
  A_SUM=A_TERM
  POW_MZP1_M = MZP1**M
  B_TERM=B_SUM_INIT_PS_ONE(A,B,GAMMA_C,GAMMA_INV_ONE_MEPS, &
       GAMMA_INV_EPS_PA_PM,GAMMA_INV_EPS_PB_PM,MZP1,M,EPS)*POW_MZP1_M
  PROD_B=POW_MZP1_M
  DO N=0,M_M2
     RATIO=(A+N)*(B+N)/(N+ONE)
     A_TERM=A_TERM*MZP1*RATIO/(N+ONE_MEPS_MM)
     A_SUM=A_SUM+A_TERM
     PROD_B = PROD_B*RATIO
  ENDDO
  IF(M.GT.0) THEN
     PROD_B = PROD_B*(A+M-ONE)*(B+M-ONE)/DBLE(M)
  ENDIF
  B_EXTRA_TERM = PROD_B*GAMMA_PROD*GAMMA_INV_ONE_MEPS; B_SUM=B_TERM
  B_PREC=EPS15*INF_NORM(B_TERM)
  CALL CV_POLY_DER_TAB_CALC(A,B,ONE_MEPS_MM,MZP1,CV_POLY1_DER_TAB)
  CALL CV_POLY_DER_TAB_CALC(EPS_PB_PM,EPS_PA_PM,EPS_PM_P1,MZP1, &
       CV_POLY2_DER_TAB)
  MIN_N=MAX(MIN_N_CALC(CV_POLY1_DER_TAB),MIN_N_CALC(CV_POLY2_DER_TAB))
  POSSIBLE_FALSE_CV=.TRUE.; N=0
  DO WHILE(POSSIBLE_FALSE_CV.OR.(INF_NORM(B_TERM).GT.B_PREC))
     N_PM_P1=N+M_P1; N_P1=N+ONE; A_PM_PN=A_PM+N; B_PM_PN=B_PM+N
     EPS_PM_P1_PN=EPS_PM_P1+N; N_P1_MEPS=ONE_MEPS+N
     EPS_PM_PN=EPS_PM+N; EPS_PA_PM_PN=EPS_PA_PM+N
     EPS_PB_PM_PN=EPS_PB_PM+N
     PROD1=EPS_PA_PM_PN*EPS_PB_PM_PN
     PROD2=EPS_PM_P1_PN*N_P1
     PROD3=A_PM_PN*B_PM_PN
     B_TERM = MZP1*(B_TERM*PROD1/PROD2+B_EXTRA_TERM*(PROD3/N_PM_P1 &
          -A_PM_PN-B_PM_PN-EPS+PROD1/N_P1)/(EPS_PM_P1_PN*N_P1_MEPS))
     B_SUM=B_SUM+B_TERM
     B_EXTRA_TERM=B_EXTRA_TERM*MZP1*PROD3/(N_PM_P1*N_P1_MEPS)
     IF(POSSIBLE_FALSE_CV.AND.(N.GT.MIN_N)) THEN
        POSSIBLE_FALSE_CV = &
             (CV_POLY_DER_CALC(CV_POLY1_DER_TAB,DBLE(N)).GT.ZERO).OR. &
             (CV_POLY_DER_CALC(CV_POLY2_DER_TAB,DBLE(N)).GT.ZERO)
     ENDIF
     N=N+1
  ENDDO
  IF(EPS.EQ.ZERO) THEN
     HYP_PS_ONE=PHASE*(A_SUM+B_SUM)
     RETURN
  ELSE
     HYP_PS_ONE=PHASE*(A_SUM+B_SUM)*PI_EPS/SIN(PI_EPS)
     RETURN
  ENDIF
END FUNCTION HYP_PS_ONE
!
!----------------------------------------------------------------------
! CALCULATION OF THE 2F1 POWER SERIES
! -----------------------------------
! CONVERGING WITH THE 1/Z TRANSFORMATION
! --------------------------------------
! THE FORMULA FOR F(Z) IN THE 1/Z TRANSFORMATION HOLDS:
! F(Z) = (-1)^M (PI.EPS)/SIN (PI.EPS) [A(Z) + B(Z)]
! FOR EPS NOT EQUAL TO ZERO,
! F(Z) = (-1)^M [A(Z) + B(Z)] FOR EPS = 0
! WHERE M = |RE(B-A)], EPS = B-A-M,
! A(Z) = \SUM_{N=0}^{M-1} ALPHA[N] Z^{-N},
! B(Z) = \SUM_{N=0}^{+OO} BETA[N] Z^{-N}, AND:
!
! ALPHA[0] = [GAMMA_INV(1-M-EPS)/EPS] GAMMA_INV(C-A)
!          X GAMMA_INV(A+M+EPS) GAMMA(C)
! [GAMMA_INV(1-M-EPS)/EPS] IS CALCULATED IN A_SUM_INIT.
! ALPHA[0] IS CALCULATED WITH LOG[GAMMA]
! IF THE PREVIOUS EXPRESSION MIGHT OVERFLOW,
! AND ITS IMAGINARY PART REMOVED IF A, B AND C ARE REAL.
! ALPHA[N+1] = (A+N)(1-C+A+N)/[(N+1)(1-M-EPS+N)] ALPHA[N],
! N IN [0:M-2].
!
! BETA[0] IS DEFINED IN B_SUM_INIT_PS_INFINITY FUNCTION COMMENTS.
! GAMMA[0] = GAMMA(C) (A)_M (1-C+A)_M Z^{-M} GAMMA_INV(A+M+EPS)
!          X GAMMA_INV(C-A) GAMMA_INV(M+1) GAMMA_INV(1-EPS)
!
! BETA[N+1] = (A+M+N+EPS)(1-C+A+M+N+EPS)/[(M+N+1+EPS)(N+1)] BETA[N]
! + [(A+M+N)(1-C+A+M+N)/(M+N+1) - (A+M+N) - (1-C+A+M+N)
! - EPS + (A+M+N+EPS)(1-C+A+M+N+EPS)/(N+1)]
! X GAMMA[N]/[(N+M+1+EPS)(N+1+EPS)], N >= 0.
! GAMMA[N+1] = (A+M+N)(B+M+N)/[(M+N+1)(N+1-EPS)] GAMMA[N], N >= 0.
!
! B(Z) CONVERGES <=> |Z| > 1
! THE TEST OF CONVERGENCE IS |BETA[N] Z^{-N}|OO < 1E-15 |BETA[0]|OO
! FOR N LARGE ENOUGH SO THAT FALSE CONVERGENCE CANNOT OCCUR.
!
! VARIABLES
! ---------
! A,B,C,Z: A,B,C PARAMETERS AND Z ARGUMENT OF 2F1(A,B,C,Z)
! M,PHASE,M_P1,EPS,A_MC_P1,ONE_MEPS,
! ONE_MEPS_PM,A_PM,A_MC_P1_PM,CMA: |RE(B-A)], (-1)^M, M+1, B-A-M,
! 1-C+A, 1-EPS, 1-EPS-M, A+M, 1-C+A+M, C-A
! EPS_PA,EPS_PM_P1,EPS_PA_MC_P1_PM,PI_EPS,EPS_PA_PM,EPS_PM,GAMMA_C:
! EPS+A, EPS+M+1, EPS+1-C+A+M, PI.EPS, EPS+A+M, EPS+M, GAMMA(C)
! GAMMA_INV_EPS_PA_PM,GAMMA_INV_CMA,Z_INV,POW_MZ_MA,
! GAMMA_INV_ONE_MEPS,GAMMA_PROD: GAMMA_INV(EPS+A+M), GAMMA_INV(C-A),
! 1/Z, (-Z)^(-A), GAMMA_INV(1-EPS),
! GAMMA(C) GAMMA_INV(C-A) GAMMA_INV(EPS+A+M)
! A_FIRST_TERM,A_SUM,A_TERM: ALPHA[0], A(Z), ALPHA[N] Z^{-N}
! POW_Z_INV_M,B_FIRST_TERM,PROD_B,RATIO: Z^{-M}, BETA[0],
! (A)_M (1-C+A)_M Z^{-M}, (A+N)(1-C+A+N)/(N+1) FOR N IN [0:M-2].
! B_EXTRA_TERM,B_TERM,B_SUM,B_PREC:
! GAMMA[N], BETA[N] Z^{-N}, B(Z), 1E-15 |BETA[0|OO
! CV_POLY1_DER_TAB,CV_POLY2_DER_TAB: P1'(X) AND P2'(X) COEFFICIENTS
! OF THE POTENTIALS DERIVATIVES OF P1(X) AND P2(X)
! DEFINED IN CV_POLY_DER_TAB_CALC
! WITH PARAMETERS A1 = A, B1 = 1-C+A, C1 = 1-M-EPS, Z1 = 1/Z
! AND A2 = B, B2 = EPS+1-C+A+M,C2 = EPS+M+1, Z2 = 1/Z.
! MIN_N: SMALLEST INTEGER AFTER WHICH FALSE CONVERGENCE CANNOT OCCUR.
!        IT IS CALCULATED IN MIN_N_CALC WITH BOTH P1'(X) AND P2'(X),
! SO ONE TAKES THE LARGEST INTEGER COMING FROM BOTH CALCULATIONS.
! POSSIBLE_FALSE_CV: ALWAYS TRUE IF N < MIN_N. IF N >= MIN_N,
! IT IS TRUE IF P1'(N) > 0 OR P2'(N) > 0.
! IF N >= MIN_N AND P1'(N) < 0 AND P2'(N) < 0,
! IT BECOMES FALSE AND REMAINS AS SUCH FOR THE REST OF THE CALCULATION.
! ONE CAN THEN CHECK IF |BETA[N] Z^N|OO < 1E-15 TO TRUNCATE THE SERIES.
! N,N_PM_P1,N_P1,A_PM_PN,A_MC_P1_PM_PN,EPS_PM_P1_PN,N_P1_MEPS,
! EPS_PA_PM_PN,EPS_PA_MC_P1_PM_PN,EPS_PM_PN:
! INDEX OF POWER SERIES, N+M+1, N+1, A+M+N, 1-C+A+M+N, EPS+M+N+1,
! N+1-EPS, EPS+A+M+N, EPS+1-C+A+M+N, EPS+M+N,
! PROD1,PROD2,PROD3: (EPS+A+M+N)(EPS+1-C+A+M+N),
! (EPS+M+1+N)(N+1), (A+M+N)(1-C+A+M+N)
!----------------------------------------------------------------------
FUNCTION HYP_PS_INFINITY(A,B,C,Z)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,Z
  INTEGER(IPR) :: N,M,PHASE,M_M2,MIN_N,MIN_N_CALC,M_P1
  REAL(PR)     :: B_PREC,N_P1,N_PM_P1,CV_POLY_DER_CALC
  COMPLEX(PR)  :: B_SUM_INIT_PS_INFINITY,LOG_GAMMA2,POW_Z_INV_M
  COMPLEX(PR)  :: HYP_PS_INFINITY,Z_INV,GAMMA_INV,RATIO
  COMPLEX(PR)  :: EPS,A_MC_P1,ONE_MEPS,ONE_MEPS_MM,A_PM,A_MC_P1_PM
  COMPLEX(PR)  :: CMA,EPS_PA,EPS_PM_P1,EPS_PA_MC_P1_PM,PI_EPS
  COMPLEX(PR)  :: EPS_PA_PM,EPS_PM,GAMMA_C,GAMMA_INV_CMA,POW_MZ_MA
  COMPLEX(PR)  :: A_SUM_INIT,LOG_A_SUM_INIT,A_SUM,A_TERM
  COMPLEX(PR)  :: GAMMA_INV_EPS_PA_PM,GAMMA_INV_ONE_MEPS
  COMPLEX(PR)  :: PROD_B,B_EXTRA_TERM,B_TERM,B_SUM,PROD1
  COMPLEX(PR)  :: A_PM_PN,A_MC_P1_PM_PN,EPS_PM_P1_PN,N_P1_MEPS
  COMPLEX(PR)  ::   PROD2,PROD3,GAMMA_PROD
  COMPLEX(PR)  :: EPS_PA_PM_PN,EPS_PA_MC_P1_PM_PN,EPS_PM_PN
  LOGICAL :: POSSIBLE_FALSE_CV
  REAL(PR) :: CV_POLY1_DER_TAB(0:3),CV_POLY2_DER_TAB(0:3)
  !
  M=NINT(REAL(B-A,PR)); M_M2=M-2;M_P1=M+1
  IF(MOD(M,2).EQ.0) THEN
     PHASE=1
  ELSE
     PHASE=-1
  ENDIF
  EPS=B-A-M; A_MC_P1=ONE-C+A; ONE_MEPS=ONE-EPS; ONE_MEPS_MM=ONE_MEPS-M
  A_PM=A+M; A_MC_P1_PM=A_MC_P1+M; CMA=C-A; EPS_PA=EPS+A
  EPS_PM=EPS+M; EPS_PM_P1=EPS_PM+ONE; EPS_PA_MC_P1_PM=EPS+A_MC_P1_PM
  PI_EPS=M_PI*EPS; EPS_PA_PM=EPS_PA+M
  GAMMA_C=ONE/GAMMA_INV(C); GAMMA_INV_EPS_PA_PM = GAMMA_INV(EPS_PA_PM)
  GAMMA_INV_ONE_MEPS = GAMMA_INV(ONE_MEPS)
  GAMMA_INV_CMA=GAMMA_INV(CMA); Z_INV=ONE/Z;POW_MZ_MA=(-Z)**(-A)
  GAMMA_PROD=GAMMA_C*GAMMA_INV_CMA*GAMMA_INV_EPS_PA_PM
  IF(M.EQ.0) THEN
     A_TERM=ZERO
  ELSE IF(INF_NORM(ONE_MEPS_MM &
       *(LOG(ONE + ABS(ONE_MEPS_MM))-ONE)).LT.300.0D0) THEN
     A_TERM=GAMMA_PROD*A_SUM_INIT(M,EPS,GAMMA_INV_ONE_MEPS)
  ELSE
     A_TERM=EXP(LOG_GAMMA2(C)-LOG_GAMMA2(CMA)-LOG_GAMMA2(B) &
          + LOG_A_SUM_INIT(M,EPS))
     IF((AIMAG(A).EQ.ZERO).AND.(AIMAG(B).EQ.ZERO).AND.     &
          (AIMAG(C).EQ.ZERO)) THEN
        A_TERM=REAL(A_TERM,PR)
     ENDIF
  ENDIF
  A_SUM=A_TERM
  POW_Z_INV_M=Z_INV**M
  B_TERM=B_SUM_INIT_PS_INFINITY(A,C,GAMMA_C,GAMMA_INV_CMA, &
       GAMMA_INV_ONE_MEPS,GAMMA_INV_EPS_PA_PM,Z,M,EPS)*POW_Z_INV_M
  PROD_B=POW_Z_INV_M
  DO N=0,M_M2
     RATIO=(A+N)*(A_MC_P1+N)/(N+ONE)
     A_TERM = A_TERM*Z_INV*RATIO/(N+ONE_MEPS_MM)
     A_SUM = A_SUM+A_TERM
     PROD_B = PROD_B*RATIO
  ENDDO
  IF (M.GT.0) THEN
     PROD_B=PROD_B*(A+M-ONE)*(A_MC_P1+M-ONE)/DBLE(M)
  ENDIF
  B_EXTRA_TERM = PROD_B*GAMMA_PROD*GAMMA_INV_ONE_MEPS
  B_SUM=B_TERM
  B_PREC=EPS15*INF_NORM(B_TERM)
  CALL CV_POLY_DER_TAB_CALC(A,A_MC_P1,ONE_MEPS_MM,Z_INV, &
       CV_POLY1_DER_TAB)
  CALL CV_POLY_DER_TAB_CALC(B,EPS_PA_MC_P1_PM,EPS_PM_P1, &
       Z_INV,CV_POLY2_DER_TAB)
  MIN_N=MAX(MIN_N_CALC(CV_POLY1_DER_TAB),MIN_N_CALC(CV_POLY2_DER_TAB))
  POSSIBLE_FALSE_CV=.TRUE.; N=0
  DO WHILE(POSSIBLE_FALSE_CV.OR.(INF_NORM(B_TERM).GT.B_PREC))
     N_PM_P1=N+M_P1; N_P1=N+ONE; A_PM_PN=A_PM+N
     A_MC_P1_PM_PN=A_MC_P1_PM+N; EPS_PM_P1_PN=EPS_PM_P1+N
     N_P1_MEPS=N_P1-EPS; EPS_PA_PM_PN=EPS_PA_PM+N
     EPS_PA_MC_P1_PM_PN=EPS_PA_MC_P1_PM+N; EPS_PM_PN=EPS_PM+N
     PROD1=EPS_PA_PM_PN*EPS_PA_MC_P1_PM_PN; PROD2=EPS_PM_P1_PN*N_P1
     PROD3=A_PM_PN*A_MC_P1_PM_PN
     B_TERM = Z_INV*(B_TERM*PROD1/PROD2+B_EXTRA_TERM*(PROD3/N_PM_P1 &
          -A_PM_PN-A_MC_P1_PM_PN-EPS+PROD1/N_P1)                    &
          /(EPS_PM_P1_PN*N_P1_MEPS))
     B_SUM=B_SUM+B_TERM
     B_EXTRA_TERM=B_EXTRA_TERM*Z_INV*PROD3/(N_PM_P1*N_P1_MEPS)
     IF(POSSIBLE_FALSE_CV.AND.(N.GT.MIN_N)) THEN
        POSSIBLE_FALSE_CV = (CV_POLY_DER_CALC( &
             CV_POLY1_DER_TAB,DBLE(N)).GT.ZERO).OR.(&
             CV_POLY_DER_CALC(CV_POLY2_DER_TAB,DBLE(N)).GT.ZERO)
     ENDIF
     N=N+1
  ENDDO
  IF(EPS.EQ.ZERO) THEN
     HYP_PS_INFINITY=PHASE*POW_MZ_MA*(A_SUM+B_SUM)
     RETURN
  ELSE
     HYP_PS_INFINITY=PHASE*POW_MZ_MA*(A_SUM+B_SUM)*PI_EPS &
          /SIN(PI_EPS)
     RETURN
  ENDIF
END FUNCTION HYP_PS_INFINITY
!
!----------------------------------------------------------------------
! CALCULATION OF F(Z) IN TRANSFORMATION THEORY MISSING ZONES
! ----------------------------------------------------------
! OF THE COMPLEX PLANE WITH A TAYLOR SERIES
! -----------------------------------------
! IF Z IS CLOSE TO EXP(+/- I.PI/3), NO TRANSFORMATION IN 1-Z, Z,
! Z/(Z-1) OR COMBINATION OF THEM CAN TRANSFORM Z IN A COMPLEX NUMBER
! OF MODULUS SMALLER THAN A GIVEN RMAX < 1 .
! RMAX IS A RADIUS FOR WHICH ONE CONSIDERS POWER SERIES SUMMATION
! FOR |Z| > RMAX IS TOO SLOW TO BE PROCESSED. ONE TAKES RMAX = 0.9 .
! NEVERTHELESS, FOR RMAX = 0.9,
! THESE ZONES ARE SMALL ENOUGH TO BE HANDLED
! WITH A TAYLOR SERIES EXPANSION AROUND A POINT Z0 CLOSE TO Z
! WHERE TRANSFORMATION THEORY CAN BE USED TO CALCULATE F(Z).
! ONE THEN CHOOSES Z0 TO BE 0.9 Z/|Z| IF |Z| < 1, AND 1.1 Z/|Z|
! IF |Z| > 1,
! SO THAT HYP_PS_ZERO OR HYP_PS_INFINITY CAN BE USED
! (SEE COMMENTS OF THESE FUNCTIONS ABOVE).
! FOR THIS Z0, F(Z) = \SUM_{N=0}^{+OO} Q[N] (Z-Z0)^N, WITH:
! Q[0] = F(Z0), Q[1] = F'(Z0) = (A B/C) 2F1(A+1,B+1,C+1,Z0)
! Q[N+2] = [Q[N+1] (N (2 Z0 - 1) - C + (A+B+C+1) Z0)
! + Q[N] (A+N)(B+N)/(N+1)]/(Z0(1-Z0)(N+2))
! AS |Z-Z0| < 0.1, IT CONVERGES WITH AROUND 15 TERMS,
! SO THAT NO INSTABILITY CAN OCCUR FOR MODERATE A, B AND C.
! CONVERGENCE IS TESTED
! WITH |Q[N] (Z-Z0)^N|OO + |Q[N+1] (Z-Z0)^{N+1}|OO.
! SERIES IS TRUNCATED WHEN THIS TEST IS SMALLER
! THAN 1E-15 (|Q[0]|OO + |Q[1] (Z-Z0)|OO).
! NO FALSE CONVERGENCE CAN HAPPEN HERE
! AS Q[N] BEHAVES SMOOTHLY FOR N -> +OO.
!
! VARIABLES
! ---------
! A,B,C,Z: A,B,C PARAMETERS AND Z ARGUMENT OF 2F1(A,B,C,Z)
! ABS_Z,IS_ABS_Z_SMALL: |Z|, TRUE IF |Z| < 1 AND FALSE IF NOT.
! Z0,ZC_Z0_RATIO,Z0_TERM1,Z0_TERM2: 0.9 Z/|Z| IF |Z| < 1,
! AND 1.1 Z/|Z| IF |Z| > 1, (Z-Z0)/(Z0 (1-Z0)),
! 2 Z0 - 1, C - (A+B+C+1) Z0
! HYP_PS_Z0,DHYP_PS_Z0,PREC: F(Z0), F'(Z0) CALCULATED WITH 2F1
! AS F'(Z0) = (A B/C) 2F1(A+1,B+1,C+1,Z0),
! PRECISION DEMANDED FOR SERIES TRUNCATION
! EQUAL TO 1E-15 (|Q[0]|OO + |Q[1] (Z-Z0)|OO).
! N,AN,ANP1,ANP2,SUM: INDEX OF THE SERIES, Q[N] (Z-Z0)^N,
! Q[N+1] (Z-Z0)^{N+1}, Q[N+2] (Z-Z0)^{N+2},
! TRUNCATED SUM OF THE POWER SERIES.
!----------------------------------------------------------------------
FUNCTION HYP_PS_COMPLEX_PLANE_REST(A,B,C,Z)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,Z
  INTEGER(IPR) :: N
  REAL(PR)     :: ABS_Z,PREC
  COMPLEX(PR)  :: HYP_PS_COMPLEX_PLANE_REST
  COMPLEX(PR)  :: Z0,ZC,ZC_Z0_RATIO,Z0_TERM1,Z0_TERM2
  COMPLEX(PR)  :: HYP_PS_Z0,DHYP_PS_Z0,AN,ANP1,ANP2
  COMPLEX(PR)  :: HYP_PS_ZERO,HYP_PS_INFINITY
  !
  ABS_Z=ABS(Z)
  IF(ABS_Z.LT.ONE) THEN
     Z0=0.9D0*Z/ABS_Z; ZC=Z-Z0; ZC_Z0_RATIO=ZC/(Z0*(ONE-Z0))
     Z0_TERM1=TWO*Z0 - ONE; Z0_TERM2=C-(A+B+ONE)*Z0
     HYP_PS_Z0=HYP_PS_ZERO(A,B,C,Z0)
     DHYP_PS_Z0=HYP_PS_ZERO(A+ONE,B+ONE,C+ONE,Z0)*A*B/C
  ELSE
     Z0=1.1D0*Z/ABS_Z; ZC=Z-Z0; ZC_Z0_RATIO=ZC/(Z0*(ONE-Z0))
     Z0_TERM1=TWO*Z0 - ONE; Z0_TERM2=C-(A+B+ONE)*Z0
     HYP_PS_Z0=HYP_PS_INFINITY(A,B,C,Z0)
     DHYP_PS_Z0=HYP_PS_INFINITY(A+ONE,B+ONE,C+ONE,Z0)*A*B/C
  ENDIF
  AN=HYP_PS_Z0;ANP1=ZC*DHYP_PS_Z0;HYP_PS_COMPLEX_PLANE_REST=AN+ANP1
  PREC=EPS15*(INF_NORM(AN)+INF_NORM(ANP1)); N=0
  DO WHILE(INF_NORM(AN).GT.PREC)
     ANP2=ZC_Z0_RATIO*(ANP1*(N*Z0_TERM1-Z0_TERM2)+AN*ZC*(A+N)*(B+N) &
          /(N+ONE))/(N+TWO)
     HYP_PS_COMPLEX_PLANE_REST = HYP_PS_COMPLEX_PLANE_REST + ANP2
     N=N+1
     AN=ANP1
     ANP1=ANP2
  ENDDO
  RETURN
END FUNCTION HYP_PS_COMPLEX_PLANE_REST
!
!----------------------------------------------------------------------
! CALCULATION OF F(Z) FOR ARBITRARY Z USING PREVIOUS ROUTINES
! -----------------------------------------------------------
! FIRSTLY, IT IS CHECKED IF A,B AND C ARE NEGATIVE INTEGERS.
! IF NEITHER A NOR B IS NEGATIVE INTEGER BUT C IS,
! F(Z) IS UNDEFINED SO THAT THE PROGRAM STOPS WITH AN ERROR MESSAGE.
! IF A AND C ARE NEGATIVE INTEGERS WITH C < A,
! OR B AND C ARE NEGATIVE INTEGERS WITH B < A,
! OR C IS NOT NEGATIVE INTEGER INTEGER BUT A OR B IS,
! ONE IS IN THE POLYNOMIAL CASE.
! IN THIS CASE, IF |Z| < |Z/(Z-1)| OR Z = 1,
! HYP_PS_ZERO IS USED DIRECTLY, AS THEN |Z| <= 2
! AND NO INSTABILITY ARISES WITH HYP_PS_ZERO
! AS LONG THE DEGREE OF THE POLYNOMIAL IS SMALL (<= 10 TYPICALLY).
! IF NOT, ONE USES THE TRANSFORMATION
! F(Z) = (1-Z)^{-A} 2F1(A,C-B,C,Z/(Z-1)) IF A IS NEGATIVE INTEGER
! OR F(Z) = (1-Z)^{-B} 2F1(B,C-A,C,Z/(Z-1)) IF B IS NEGATIVE INTEGER
! ALONG WITH HYP_PS_ZERO.
! INDEED, 2F1(A,C-B,C,X) IS A POLYNOMIAL IF A IS NEGATIVE INTEGER,
! AND SO IS 2F1(B,C-A,C,X) IF B IS NEGATIVE INTEGER,
! SO THAT ONE HAS HERE |Z/(Z-1)| <= 2
! AND THE STABILITY OF THE METHOD IS THE SAME
! AS FOR THE |Z| < |Z/(Z-1)| CASE.
! IF ONE IS IN THE NON-POLYNOMIAL CASE, ONE CHECKS IF Z >= 1.
! IF IT IS, ONE IS THE CUT OF F(Z)
! SO THAT Z IS REPLACED BY Z - 10^{-307}I.
! THEN, USING F(Z) = 2F1(B,A,C,Z)
! AND F(Z) = (1-Z)^{C-A-B} 2F1(C-A,C-B,C,Z),
! ONE REPLACES A,B,C PARAMETERS BY COMBINATIONS OF THEM
! SO THAT RE(B-A) >= 0 AND RE(C-A-B) >= 0.
! EXCHANGING A AND B DOES NOT CHANGE CONVERGENCE PROPERTIES,
! WHILE HAVING RE(C-A-B) >= 0 ACCELERATES IT
! (IN HYP_PS_ZERO, T[N] Z^N ~ Z^N/(N^{C-A-B}) FOR N -> +OO).
! IF |1-Z| < 1E-5, ONE USES HYP_PS_ONE
! AS THE VICINITY OF THE SINGULAR POINT Z = 1 IS TREATED PROPERLY.
! AFTER THAT, ONE COMPARES |Z| AND |Z/(Z-1)|
! TO R IN {0.5,0.6,0.7,0.8,0.9}.
! IF ONE OF THEM IS SMALLER THAN R,
! ONE USES HYP_PS_ZERO WITHOUT TRANSFORMATION
! OR WITH THE TRANSFORMATION F(Z) = (1-Z)^{-A} 2F1(A,C-B,C,Z/(Z-1)).
! THEN, IF BOTH OF THEM ARE LARGER THAN 0.9,
! ONE COMPARES |1/Z|, |(Z-1)/Z|, |1-Z| AND |1/(1-Z)|
! TO R IN {0.5,0.6,0.7,0.8,0.9}.
! IF ONE OF THEM IS FOUND SMALLER THAN R,
! WITH THE CONDITION THAT |C-B|OO < 5 FOR (Z-1)/Z TRANSFORMATION,
! |A,B,C|OO < 5 FOR |1-Z| TRANSFORMATION
! AND |A,C-B,C|OO < 5 FOR |1/(1-Z)| TRANSFORMATION,
! THE CORRESPONDING TRANSFORMATION IS USED.
! IF NONE OF THEM WAS SMALLER THAN 0.9,
! ONE IS IN THE MISSING ZONES OF TRANSFORMATION THEORY
! SO THAT THE TAYLOR SERIES OF HYP_PS_COMPLEX_PLANE_REST IS USED.
!
! VARIABLES
! ---------
! A,B,C,Z: A,B,C PARAMETERS AND Z ARGUMENT OF 2F1(A,B,C,Z)
! RE_A,RE_B,RE_C,NA,NB,NC,IS_A_NEG_INT,IS_B_NEG_INT,IS_C_NEG_INT:
! REAL PARTS OF A,B,C, CLOSEST INTEGERS TO A,B,C,
! TRUE IF A,B,C IS NEGATIVE INTEGERS AND FALSE IF NOT.
! ZM1,Z_OVER_ZM1,Z_SHIFT: Z-1, Z/(Z-1), Z - 10^{-307}I IN CASE Z >= 1.
! AB_CONDITION, CAB_CONDITION: TRUE IF RE(B-A) >= 0 AND FALSE IF NOT,
! TRUE IF RE(C-A-B) >= 0 AND FALSE IF NOT.
! ABS_ZM1,ABZ_Z,ABS_Z_INV,ABS_Z_OVER_ZM1,ABS_ZM1_INV,ABS_ZM1_OVER_Z:
! |Z-1|, |Z|, |1/Z|, |Z/(Z-1)|, |1/(Z-1)|, |(Z-1)/Z|
! ARE_AC_SMALL: TRUE IF |A|OO < 5 AND |C|OO < 5, FALSE IF NOT.
! IS_CMB_SMALL: TRUE IF |C-B|OO < 5, FALSE IF NOT.
! ARE_ABC_SMALL: TRUE IF |A|OO < 5, |B|OO < 5 AND |C|OO < 5,
! FALSE IF NOT.
! ARE_A_CMB_C_SMALL: TRUE IF |A|OO < 5, |C-B|OO < 5 AND |C|OO < 5,
! FALSE IF NOT.
! R_TAB,R: TABLE OF RADII {0.5,0.6,0.7,0.8,0.9}, ONE OF THESE RADII.
! RES: RETURNED RESULT
!----------------------------------------------------------------------
RECURSIVE FUNCTION HYP_2F1(A,B,C,Z) RESULT(RES)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,Z
  INTEGER(IPR) :: NA,NB,NC,I
  REAL(PR)     :: RE_A,RE_B,RE_C,ABS_Z,ABS_ZM1,ABS_Z_OVER_ZM1
  REAL(PR)     :: ABS_ZM1_OVER_Z,ABS_ZM1_INV,R_TABLE(1:5),R,ABS_Z_INV
  COMPLEX(PR)  :: RES,HYP_PS_INFINITY,HYP_PS_ZERO,Z_SHIFT
  COMPLEX(PR)  :: HYP_PS_COMPLEX_PLANE_REST,HYP_PS_ONE,Z_OVER_ZM1,ZM1
  LOGICAL      :: IS_A_NEG_INT,IS_B_NEG_INT,IS_C_NEG_INT
  LOGICAL      :: AB_CONDITION,CAB_CONDITION,ARE_A_CMB_C_SMALL
  LOGICAL      :: IS_CMB_SMALL,ARE_AC_SMALL,ARE_ABC_SMALL
  !
  RE_A=REAL(A,PR); RE_B=REAL(B,PR); RE_C=REAL(C,PR);
  NA=NINT(RE_A); NB=NINT(RE_B); NC=NINT(RE_C);
  IS_A_NEG_INT=A.EQ.NA.AND.NA.LE.0
  IS_B_NEG_INT=B.EQ.NB.AND.NB.LE.0
  IS_C_NEG_INT=C.EQ.NC.AND.NC.LE.0
  ZM1=Z-ONE
  IF(IS_C_NEG_INT) THEN
     ABS_Z=ABS(Z); Z_OVER_ZM1 = Z/ZM1
     ABS_Z_OVER_ZM1=ABS(Z_OVER_ZM1)
     IF(IS_A_NEG_INT.AND.(NC.LT.NA)) THEN
        IF((Z.EQ.ONE).OR.(ABS_Z.LT.ABS_Z_OVER_ZM1)) THEN
           RES=HYP_PS_ZERO(A,B,C,Z)
           RETURN
        ELSE
           RES=((-ZM1)**(-A))*HYP_PS_ZERO(A,C-B,C,Z_OVER_ZM1)
           RETURN
        ENDIF
     ELSE IF(IS_B_NEG_INT.AND.(NC.LT.NB)) THEN
        IF((Z.EQ.ONE).OR.(ABS_Z.LT.ABS_Z_OVER_ZM1)) THEN
           RES=HYP_PS_ZERO(A,B,C,Z)
           RETURN
        ELSE
           RES=((-ZM1)**(-B))*HYP_PS_ZERO(B,C-A,C,Z_OVER_ZM1)
           RETURN
        ENDIF
     ELSE
        STOP '2F1 UNDEFINED'
     ENDIF
  ENDIF
  IF(IS_A_NEG_INT) THEN
     ABS_Z=ABS(Z); Z_OVER_ZM1 = Z/ZM1
     ABS_Z_OVER_ZM1=ABS(Z_OVER_ZM1)
     IF((Z.EQ.ONE).OR.(ABS_Z.LT.ABS_Z_OVER_ZM1)) THEN
        RES=HYP_PS_ZERO(A,B,C,Z)
        RETURN
     ELSE
        RES=((-ZM1)**(-A))*HYP_PS_ZERO(A,C-B,C,Z_OVER_ZM1)
        RETURN
     ENDIF
  ELSE IF(IS_B_NEG_INT) THEN
     ABS_Z=ABS(Z); Z_OVER_ZM1 = Z/ZM1
     ABS_Z_OVER_ZM1=ABS(Z_OVER_ZM1)
     IF((Z.EQ.ONE).OR.(ABS_Z.LT.ABS_Z_OVER_ZM1)) THEN
        RES=HYP_PS_ZERO(A,B,C,Z)
        RETURN
     ELSE
        RES=((-ZM1)**(-B))*HYP_PS_ZERO(B,C-A,C,Z_OVER_ZM1)
        RETURN
     ENDIF
  ENDIF
  IF((REAL(Z,PR).GE.ONE).AND.(AIMAG(Z).EQ.ZERO)) THEN
     Z_SHIFT=CMPLX(REAL(Z,PR),-1.0D-307,PR)
     RES=HYP_2F1(A,B,C,Z_SHIFT)
     RETURN
  ENDIF
  AB_CONDITION = (RE_B.GE.RE_A)
  CAB_CONDITION = (RE_C.GE.RE_A + RE_B)
  IF ((.NOT.AB_CONDITION).OR.(.NOT.CAB_CONDITION)) THEN
     IF ((.NOT.AB_CONDITION).AND.(CAB_CONDITION)) THEN
        RES=HYP_2F1(B,A,C,Z)
        RETURN
     ELSE IF((.NOT.CAB_CONDITION).AND.(AB_CONDITION)) THEN
        RES=((-ZM1)**(C-A-B))*HYP_2F1(C-B,C-A,C,Z)
        RETURN
     ELSE
        RES=((-ZM1)**(C-A-B))*HYP_2F1(C-A,C-B,C,Z)
        RETURN
     ENDIF
  ENDIF
  ABS_ZM1=ABS(ZM1)
  IF(ABS_ZM1.LT.1D-5) THEN
     RES=HYP_PS_ONE (A,B,C,-ZM1)
     RETURN
  ENDIF
  ABS_Z=ABS(Z); ABS_Z_OVER_ZM1=ABS_Z/ABS_ZM1; ABS_Z_INV=ONE/ABS_Z
  ABS_ZM1_OVER_Z=ONE/ABS_Z_OVER_ZM1; ABS_ZM1_INV=ONE/ABS_ZM1
  IS_CMB_SMALL = INF_NORM(C-B).LT.5.0D0;
  ARE_AC_SMALL = (INF_NORM(A).LT.5.0D0).AND.(INF_NORM(C).LT.5.0D0)
  ARE_ABC_SMALL = ARE_AC_SMALL.AND.(INF_NORM(B).LT.5.0D0)
  ARE_A_CMB_C_SMALL = ARE_AC_SMALL.AND.IS_CMB_SMALL
  R_TABLE=(/0.5D0,0.6D0,0.7D0,0.8D0,0.9D0/)
  DO I=1,5
     R=R_TABLE(I)
     IF(ABS_Z.LE.R) THEN
        RES=HYP_PS_ZERO (A,B,C,Z)
        RETURN
     ENDIF
     IF(IS_CMB_SMALL.AND.(ABS_Z_OVER_ZM1.LE.R)) THEN
        RES=((-ZM1)**(-A))*HYP_PS_ZERO (A,C-B,C,Z/ZM1)
        RETURN
     ENDIF
  ENDDO
  DO I=1,5
     R=R_TABLE(I)
     IF(ABS_Z_INV.LE.R) THEN
        RES=HYP_PS_INFINITY (A,B,C,Z)
        RETURN
     ENDIF
     IF(IS_CMB_SMALL.AND.(ABS_ZM1_OVER_Z.LE.R)) THEN
        RES=((-ZM1)**(-A))*HYP_PS_INFINITY (A,C-B,C,Z/ZM1)
        RETURN
     ENDIF
     IF(ARE_ABC_SMALL.AND.(ABS_ZM1.LE.R)) THEN
        RES=HYP_PS_ONE (A,B,C,-ZM1)
        RETURN
     ENDIF
     IF(ARE_A_CMB_C_SMALL.AND.(ABS_ZM1_INV.LE.R)) THEN
        RES=((-ZM1)**(-A))*HYP_PS_ONE (A,C-B,C,-ONE/ZM1)
        RETURN
     ENDIF
  ENDDO
  RES=HYP_PS_COMPLEX_PLANE_REST (A,B,C,Z)
  RETURN
END FUNCTION HYP_2F1
!
!----------------------------------------------------------------------
! TEST OF 2F1 NUMERICAL ACCURACY
! ------------------------------
! USING HYPERGEOMETRIC DIFFERENTIAL EQUATION
! ------------------------------------------
! IF Z = 0, F(Z) = 1 SO THAT THIS VALUE IS TRIVIALLY TESTED.
! TO TEST OTHERWISE IF THE VALUE OF F(Z) IS ACCURATE,
! ONE USES THE FACT THAT
! Z(Z-1) F''(Z) + (C - (A+B+1) Z) F'(Z) - A B F(Z) = 0.
! IF Z IS NOT EQUAL TO ONE, A RELATIVE PRECISION TEST IS PROVIDED
! BY |F''(Z) + [(C - (A+B+1) Z) F'(Z) - A B F(Z)]/[Z(Z-1)]|OO
! /(|F(Z)|OO + F'(Z)|OO + |F''(Z)|OO).
! IF Z IS EQUAL TO ONE, ONE USES |(C - (A+B+1)) F'(Z) - A B F(Z)|OO
! /(|F(Z)|OO + F'(Z)|OO + 1E-307).
! F'(Z) AND F''(Z) ARE CALCULATED USING EQUALITIES
! F'(Z) = (A B/C) 2F1(A+1,B+1,C+1,Z)
! AND F'(Z) = ((A+1)(B+1)/(C+1)) (A B/C) 2F1(A+2,B+2,C+2,Z).
!
! VARIABLES
! ---------
! A,B,C,Z: A,B,C PARAMETERS AND Z ARGUMENT OF 2F1(A,B,C,Z)
! F,DF,D2F: F(Z), F'(Z) AND F''(Z) CALCULATED WITH HYP_2F1 
! USING F'(Z) = (A B/C) 2F1(A+1,B+1,C+1,Z)
! AND F'(Z) = ((A+1)(B+1)/(C+1)) (A B/C) 2F1(A+2,B+2,C+2,Z).
!----------------------------------------------------------------------
FUNCTION TEST_2F1(A,B,C,Z,F)
  !--------------------------------------------------------------------
  USE HYP_2F1_MODULE
  IMPLICIT NONE
  COMPLEX(PR),INTENT(IN) :: A,B,C,Z
  REAL(PR)    :: TEST_2F1
  COMPLEX(PR) :: F,DF,D2F,HYP_2F1
  !
  IF(Z.EQ.ZERO) THEN
     TEST_2F1=INF_NORM(F-ONE)
     RETURN
  ELSE IF(Z.EQ.ONE) THEN
     DF = HYP_2F1(A+ONE,B+ONE,C+ONE,Z)*A*B/C
     TEST_2F1=INF_NORM((C-(A+B+ONE))*DF-A*B*F) &
          /(INF_NORM (F)+INF_NORM(DF)+1D-307)
     RETURN
  ELSE
     DF = HYP_2F1(A+ONE,B+ONE,C+ONE,Z)*A*B/C
     D2F = HYP_2F1(A+TWO,B+TWO,C+TWO,Z)*A*(A+ONE)*B*(B+ONE) &
          /(C*(C+ONE))
     TEST_2F1=INF_NORM(D2F+((C-(A+B+ONE)*Z)*DF-A*B*F)/(Z*(ONE-Z))) &
          /(INF_NORM(F)+INF_NORM(DF)+INF_NORM(D2F))
     RETURN
  ENDIF
END FUNCTION TEST_2F1
!
!============== END HYP_2F1 FILE ======================================
