MODULE m_rtt

  ! Purpose:
  !   To provide routines to compute envelopes resulting from multiple scattering of S-wave only and P-/S-waves generated by impulsive
  !   sources in unbounded heterogeneous media with constant background velocity based on the radiative transfer theory. Scattering
  !   can be nonisotropic (S-waves only) or isotropic (P-/S-waves). For isotropic scattering of S-waves only, the approximate solution
  !   of Paasschens (less than 3% relative error, except around direct S-wave) is available as well.
  !
  !   Computational time is sensibly higher for strong forward scattering as the evaluation of 2F1 (hypergeometric function) can be
  !   very expensive.
  !
  !   Precision is determined at compile time by adding (or not) the "-DDOUBLE_PREC" flag.
  !
  ! Revisions:
  !     Date                    Description of change
  !     ====                    =====================
  !   02/09/20                  original version
  !

  USE, INTRINSIC     :: iso_c_binding
  USE, INTRINSIC     :: iso_fortran_env, stdout => output_unit
  USE, NON_INTRINSIC :: m_precisions
  USE, NON_INTRINSIC :: m_fft_real
  USE, NON_INTRINSIC :: m_interpolation_r64
  USE, NON_INTRINSIC :: m_llsq_r64
#ifdef MPI
  USE, NON_INTRINSIC :: mpi
#endif

  IMPLICIT none

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --

  PRIVATE

  PUBLIC :: rtt, query_fft_size

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --

  INTERFACE rtt
    MODULE PROCEDURE rtt_nonisotropic, rtt_isotropic, paasschens
  END INTERFACE rtt

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --

  INTERFACE legendre
    REAL(c_r64) FUNCTION legendre_sphplm(l, m, x) BIND(c, name="gsl_sf_legendre_sphPlm" )
      USE, INTRINSIC     :: iso_c_binding
      USE, NON_INTRINSIC :: m_precisions
      INTEGER(c_i32), VALUE :: l, m
      REAL(c_r64),    VALUE :: x
    END FUNCTION legendre_sphplm
  END INTERFACE legendre

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --

  PROCEDURE(re_gsgp), POINTER :: re_fun, im_fun

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --

  COMPLEX(r64)                                      :: wgp, wgs
  INTEGER(i32),                           PARAMETER :: nfft = 1024
  INTEGER(i32),                           PARAMETER :: time_factor = 25       !< % of time increase
  LOGICAL                                           :: norm = .false.
  INTEGER(i32)                                      :: lmax                   !< maximum order of expansion
  REAL(r32)                                         :: hurst                  !< hurst exponent for function integration
  REAL(r64)                                         :: e0_p, e0_s             !< initial P-/S-waves at source
  REAL(r64)                                         :: alpha, beta            !< average P-/S-wave speed
  REAL(r64)                                         :: veta_pp, veta_ss       !< P-to-P, S-to-S scattering
  REAL(r64)                                         :: veta_ps, veta_sp       !< P-to-S, S-to-P scattering
  REAL(r64)                                         :: vsquared               !< term to evaluate single-scattering term
  COMPLEX(r64)                                      :: ms
  REAL(r64),                              PARAMETER :: pi = 3.14159265358979323846_r64
  REAL(r64),    ALLOCATABLE, DIMENSION(:)           :: coef                   !< expansion coefficients
  REAL(r64),    ALLOCATABLE, DIMENSION(:)           :: wigner                 !< store non-zero Wigner 3j symbol
  REAL(r64),    ALLOCATABLE, DIMENSION(:)           :: gammal                 !< gamma factor for spherical Bessel functions

  !$OMP THREADPRIVATE (wgp, wgs, ms, vsquared)

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --

  CONTAINS

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

#ifdef MPI
    SUBROUTINE rtt_nonisotropic(comm, pprank, time, ts, eta_s, eta_i, vel, acf, hurst, nu, tau, envelope, ok)
#else
    SUBROUTINE rtt_nonisotropic(time, ts, eta_s, eta_i, vel, acf, hurst, nu, tau, envelope, ok)
#endif
      ! Purpose:
      !   To return the envelope resulting from multiple scattering of S-waves generated by an impulsive source embedded in unbounded
      !   heterogeneous media having background velocity "vel" and described by the scattering parameter "eta_s" (omega/2/Qs). The
      !   angle between the direction of propagation and the axially-symmetric scattered energy particle is described by "nu"
      !   ([correlation_length * wave_number]**2) and the autocorrelation function "acf" (eventually including Hurst exponent "hurst").
      !   Scattering can be isotropic ("nu" = 0) or foward ("nu" >> 0). Backscattering is modelled by negative "nu" values. Intrinsic
      !   attenuation is expressed by "eta_i" (omega/2/Qi). The routine returns result into vector "envelope", ranging from time zero
      !   to "tmax", where the direct S-wave arrival-time is "ts". The envelope is normalized to 1 if "scaling" is set to true.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !   02/09/20
      !

#ifdef MPI
      INTEGER(i32),                         INTENT(IN)  :: comm
      INTEGER(i32), DIMENSION(:),           INTENT(IN)  :: pprank
#endif
      REAL(r32),    DIMENSION(:),           INTENT(IN)  :: time
      REAL(r32),                            INTENT(IN)  :: ts, eta_s, eta_i, vel
      CHARACTER(2),                         INTENT(IN)  :: acf
      REAL(r32),                            INTENT(IN)  :: hurst, nu, tau
      REAL(r32),    DIMENSION(SIZE(time)),  INTENT(OUT) :: envelope
      INTEGER(i32),                         INTENT(OUT) :: ok
      COMPLEX(r64), DIMENSION(nfft/2+1)                 :: spectrum
      INTEGER(i32)                                      :: i, is, lu, i0, i1, rank, ierr
      INTEGER(i32)                                      :: nwigner, npts
#ifdef MPI
      INTEGER(i32), DIMENSION(SIZE(pprank))             :: displs
#endif
      REAL(r64)                                         :: t, dt, sr, tcalc, c0, x, b
      REAL(r64)                                         :: w, dw, wi, epsabs, re, im, kmin
      REAL(r64),    DIMENSION(2)                        :: a
      REAL(r64),    DIMENSION(6)                        :: tictoc
      REAL(r64),    DIMENSION(nfft)                     :: e_multi, e_time
      REAL(r64),    DIMENSION(SIZE(time))               :: e0, e1, em, dtime

      !-----------------------------------------------------------------------------------------------------------------------------

      ok = 0

#ifdef MPI
      CALL mpi_comm_rank(comm, rank, ierr)

      rank = rank + 1
#endif

      CALL watch_start(tictoc(1))

      ! assign average velocity to global variable
      beta = vel

      npts = SIZE(time)

      ! define maximum time for m-th term energy envelope calculation
      tcalc = time(npts) * (1._r64 + time_factor / 100._r64)

      ! equivalent source-receiver distance
      sr = beta * ts

      ! evaluate paaschens' heuristic solution for multiple isotropic scattering at S-wave arrival time and maximum time
      CALL paasschens([REAL(ts, r64), tcalc], REAL(ts, r64), beta, REAL(eta_s, r64), 0._r64, a)

      ! estimate imaginary shift: because of the periodicity introduced by the wavenumber summation, energy "a(2)" at time "tmax"
      ! (which will be aliased in time) must be much smaller than energy "a(1)", i.e. "a(2)*exp(-wi*tcalc) << a(1)". This condition
      ! can be set as "a(1)*exp(wi*tcalc) = 500*a(2)" or "wi = ln(large_number*a(2)/a(1)) / tcalc".
      wi = LOG(1.e+05_r64 * a(2) / a(1)) / tcalc

      ! set absolute accuracy for numerical integration. Divide by 100 to set relative accuracy to 10^-2
      epsabs = MAX(MIN(a(1), a(2)) / 100._r64, EPSILON(1._r64))

      ! define minimum wavenumber for integration (kmin << pi / L, eq. 4.125 of Jensen et al., 2011)
      kmin = pi / (beta * tcalc + sr) / 5._r64

      ! time resolution of multiple scattering envelope
      dt = tcalc / nfft

      ! angular frequency resolution
      dw = 2.0 * pi / nfft / dt

      CALL watch_start(tictoc(2))

      ! return expansion coefficients of scattering function ("lmax", "coef")
      CALL scattering_pattern(acf, REAL(hurst, r64), REAL(nu, r64), ok)

      CALL watch_stop(tictoc(2))

      ! multiply expansion and scattering coefficients
      coef(:) = coef(:) * eta_s

      ! determine number of Wigner 3j symbols needed
      ! nwigner = (lmax*2 + 1)**2 * (lmax + 1)**2 * (lmax + 1)
      nwigner = (lmax + 1)**2 * (2*lmax + 1)

      ALLOCATE(wigner(nwigner))

      CALL watch_start(tictoc(3))

      ! pre-compute wigner 3j symbol values
      CALL fill_wigner()

      CALL watch_stop(tictoc(3))

      ALLOCATE(gammal(2*lmax - 1))

      CALL watch_start(tictoc(4))

      ! compute and store a factor used to evaluate spherical Bessel functions of order larger than 1
      DO i = 2, 2*lmax
        gammal(i - 1) = SQRT(pi) * GAMMA(i + 1._r64) / GAMMA(i + 1.5_r64)
      ENDDO

      CALL watch_stop(tictoc(4))

      ! select functions for integration
      re_fun => re_f0_m
      im_fun => im_f0_m

      i0 = 1
      i1 = nfft/2 + 1

#ifdef MPI
      displs(1) = 0

      DO i = 2, SIZE(pprank)
        displs(i) = displs(i - 1) + pprank(i - 1)
      ENDDO

      i0 = displs(rank) + 1
      i1 = i0 + pprank(rank) - 1
#endif

      CALL watch_start(tictoc(5))

      !$omp parallel do default(shared) private(i, w) reduction(max: ok) firstprivate(gammal, coef, wigner)
      DO i = i0, i1

        w = dw * (i - 1)

        ! Complex frequency, including imaginary component
        ! wgs = CMPLX(eta_s + eta_i + wi/avevel, w/avevel)
        wgs = CMPLX(eta_s + wi/beta, w/beta, r64)

        ! smoothing wavelet
        ms = EXP(-tau**2 * w**2 / 16._r64)
        ! IF (w .eq. 0._r64) THEN
        !   ms = CMPLX(1._r64, 0._r64)
        ! ELSE
        !   ms = 2._r64 * CMPLX(COS(pi*0.25_r64), -SIN(pi*0.25_r64)) * SQRT(tau * w)
        !   ms = ms / SIN(ms)
        ! ENDIF

        ! solve integral for multiple scattering term at i-th frequency
        CALL solve_integral_multi(kmin, sr, epsabs, spectrum(i), ok)

      ENDDO
      !$omp end parallel do

      CALL watch_stop(tictoc(5))

#ifdef MPI
      ! exchange data inside communicator
      CALL mpi_allgatherv(mpi_in_place, 0, mpi_datatype_null, spectrum, pprank, displs, mpi_double_complex, comm, ierr)
#endif

      DEALLOCATE(gammal, wigner)

      CALL watch_start(tictoc(6))

      CALL make_fftw_plan([nfft])
      CALL ifft(e_multi, spectrum)
      CALL destroy_fftw_plan([nfft])

      ! scaling factor for m-th order scattering
      c0 = 0.5_r64 / (sr * pi**2) / dt

      ! compensate for imaginary frequency "wi" and add scaling factor
      DO i = 1, nfft
        e_multi(i) = e_multi(i) * EXP(wi * (i - 1) * dt) * c0
        e_time(i) = (i - 1) * dt
      ENDDO

      CALL setup_interpolation('linear', 'zero', ok)

      dtime = time

      CALL interpolate(e_time, e_multi, dtime, em)

      CALL watch_stop(tictoc(6))

      ! now "dt" is the final time-step
      dt = time(2) - time(1)

      em(1:NINT(ts / dt)) = 0._r64

      ! ============================================================================================================================
      ! -------------------------------------------------- DIRECT WAVE TERM --------------------------------------------------------
      ! ============================================================================================================================

      ! scaling factor
      c0 = 0.5_r64 / (pi * SQRT(pi) * tau * sr**2)

      b  = c0 * EXP(-eta_s * beta * ts) / beta
      c0 = 4._r64 / tau**2

      DO i = 1, npts
        e0(i) = b * EXP(-c0 * (time(i) - ts)**2)
      ENDDO


      ! e0(:)  = 0._r64
      ! e1(:)  = 0._r64
      !
      ! is = NINT(ts / dt) + 1
      !
      ! lu = 1
      !
      ! DO
      !
      !   epsabs = 0._r64
      !   b      = 0._r64
      !
      !   DO i = is + 1, npts
      !     e0(i)  = e0(i) + (-1)**(lu + 1) * lu**2 * EXP(-lu**2 * pi**2 * (time(i) - ts) * 0.25_r64 / tau)
      !     epsabs = MAX(epsabs, ABS(e0(i)-e1(i)))
      !     b      = MAX(b, ABS(e0(i)))
      !     e1(i)  = e0(i)
      !   ENDDO
      !
      !   IF (epsabs / b .lt. 1.e-07_r64) EXIT
      !
      !   lu = lu + 1
      !
      ! ENDDO
      !
      ! c0 = 0.25_r64 * pi / (sr**2 * 2._r64 * tau) * EXP(-eta_s * beta *ts) / beta
      !
      ! DO i = 1, npts
      !   e0(i) = c0 * e0(i)
      ! ENDDO


      ! e0(:) = 0._r64
      !
      ! is = NINT(ts / dt) + 1
      !
      ! ! scaling factor
      ! c0 = 0.25_r64 / (pi * sr**2)
      !
      ! e0(is) = c0 * EXP(-eta_s * beta * ts) / beta

      ! ============================================================================================================================
      ! ----------------------------------------------- SINGLE SCATTERING TERM -----------------------------------------------------
      ! ============================================================================================================================

      ! e1(:) = 0._r64
      !
      ! CALL watch_start(tictoc(6))
      !
      ! !$omp parallel do default(shared) private(i, x) reduction(max: ok)
      ! DO i = 1, npts
      !
      !   IF (time(i) .gt. ts) THEN
      !
      !     vsquared = (beta * time(i) / sr)**2
      !
      !     CALL solve_integral_single(x, ok)
      !
      !     e1(i) = x * EXP(-time(i) * eta_s * beta) * c0
      !
      !   ENDIF
      !
      ! ENDDO
      ! !$omp end parallel do
      !
      ! CALL watch_stop(tictoc(6))

      ! ============================================================================================================================
      ! --------------------------------------------- ADD INTRINSIC ATTENUATION ----------------------------------------------------
      ! ============================================================================================================================

      b = eta_i * beta
      DO i = 1, npts
        ! envelope(i) = (e0(i) + e1(i) + em(i)) * EXP(-b * time(i))
        envelope(i) = (e0(i) + em(i)) * EXP(-b * time(i))
      ENDDO

      DEALLOCATE(coef)

      CALL watch_stop(tictoc(1))

#ifdef DEBUG

      OPEN(newunit = lu, file = 'rtt_nonisotropic.txt', status = 'unknown', form = 'formatted', access = 'sequential', &
           action = 'write', iostat = ok)
      ! WRITE(lu, *) ' Time    Direct wave   Single order   Higher order    Total'
      DO i = 1, npts
        WRITE(lu, '(5(G0, 3X))') time(i), e0(i), em(i), envelope(i)
      ENDDO
      CLOSE(lu)

      WRITE(stdout, '(A)') '                     Total  |   Expansion   |    Wigner3j   |     Gamma     |  Integration  |' //  &
                                                        '   FFT/interp  |'
      WRITE(stdout, '(A,6(ES14.3,A))') 'Elapsed time:', tictoc(1), ' |', tictoc(2), ' |', tictoc(3), ' |', tictoc(4), ' |',   &
                                                        tictoc(5), ' |', tictoc(6), ' |'

#endif

    END SUBROUTINE rtt_nonisotropic

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE scattering_pattern(acf, hurst, nu, ok)

      ! Purpose:
      !   To return the expansion coefficients of the scattering pattern function as determined by the selected autocorrelation
      !   function "acf", hurst coefficient "hurst" and parameter "nu" ([correlation_length * wave_number]**2). This routine returns
      !   the minimum amount of harmonics and their coefficients such that the rms error between the target and actual scattering
      !   pattern is less than "epsilon". These quantities are stored in global variables "lmax" and "coef", respectively.
      !   Expansion is limited to the first "ndegree" + 1 harmonics: an error is generated if these harmonics are not sufficient to
      !   reproduce the sought scattering pattern (e.g. strong forward scattering)
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      CHARACTER(2),                                       INTENT(IN)  :: acf
      REAL(r64),                                          INTENT(IN)  :: hurst, nu
      INTEGER(i32),                                       INTENT(OUT) :: ok
      INTEGER(i32)                                                    :: i, j, k, lu, npsi
      INTEGER(c_i32)                                                  :: l
      INTEGER(c_i32),                           PARAMETER             :: m = 0
      INTEGER(i32),                             PARAMETER             :: ndegree = 20
      REAL(r64)                                                       :: coefficient, rad
      REAL(c_r64)                                                     :: x
      REAL(r64),     ALLOCATABLE,DIMENSION(:)                         :: obs, syn, delta, pattern, psi
      REAL(r64),     ALLOCATABLE,DIMENSION(:,:)                       :: y, mat
      REAL(r64),                                PARAMETER             :: deg = 1._r64, epsilon = 0.01_r64

      !-----------------------------------------------------------------------------------------------------------------------------

      ok = 0

      ! find points for array with angles
      npsi = NINT(360._r64 / deg) + 1

      ALLOCATE(psi(npsi), pattern(npsi))

      ! convert degrees to radians
      rad = deg * pi / 180._r64

      ! define array with angles
      DO i = 1, npsi
        psi(i) = (i - 1) * rad
      ENDDO

      ! define scattering pattern based on the selected scattering pattern FUNCTION
      IF (acf .eq. 'vk') THEN

        ! define angle-independent coefficient
        IF (nu .ne. 0._r64) THEN
          coefficient = 4._r64 * nu * (hurst + 0.5_r64) / (1._r64 - (4._r64 * nu + 1)**(-0.5_r64 - hurst))
        ELSE
          coefficient = 1._r64
        ENDIF

        ! compute scattering pattern function
        DO i = 1,npsi
          pattern(i) = coefficient / (1._r64 + 4._r64 * nu * SIN(psi(i) / 2._r64)**2)**(hurst + 1.5_r64)
        ENDDO

      ELSE IF (acf .eq. 'gs') THEN

        ! define angle-independent coefficient
        IF (nu .ne. 0.) THEN
          coefficient = nu / (1._r64 - exp(-nu))
        ELSE
          coefficient = 1._r64
        ENDIF

        ! compute scattering pattern FUNCTION
        DO i = 1, npsi
          pattern(i) = coefficient * exp(-nu * SIN(psi(i) / 2._r64)**2)
        ENDDO

      ENDIF

      ! normalize psdf
      ! IF (norm) pattern(:) = pattern(:) / 4._r64 / pi

      ALLOCATE(y(npsi, ndegree + 1))

      ! compute spherical harmonic coefficients on unitary sphere for l/=0 and m=0
      DO i = 1, npsi
        x = COS(psi(i))                                   !< argument Legendre polynomial
        DO l = 0, ndegree
          y(i, l + 1) = legendre_sphplm(l, m, x)          !< normalized spherical harmonic
        ENDDO
      ENDDO

      ! copy arrays, since these will be overwritten
      !ALLOCATE(mat, source = y)
      !ALLOCATE(obs, source = pattern)
      mat = y
      obs = pattern

      ! solve linear system to find harmonics coefficients
      CALL llsq_solver(mat, obs, ok)

      DEALLOCATE(mat)

      IF (ok .ne. 0) THEN
        ok = 1
        RETURN
      ENDIF

      ALLOCATE(syn(npsi), delta(npsi))

      syn(:) = 0._r64

      ok = 2

      ! loop over harmonics and exit when rms error between target and synthesized scattering patterns is less than "epsilon"
      DO j = 0, ndegree

        DO i = 1, npsi
          syn(i)   = obs(j + 1) * y(i, j + 1) + syn(i)
          delta(i) = pattern(i) - syn(i)
        ENDDO

        IF (rms(delta) .le. epsilon) THEN
          lmax = j
          ALLOCATE(coef(lmax + 1))
          coef(1:lmax + 1) = obs(1:lmax + 1)                          !< save expansion coefficients
          ok = 0
          EXIT
        ENDIF

      ENDDO

#ifdef DEBUG

      OPEN(newunit = lu, file = 'scattering_pattern.txt', status = 'unknown', form = 'formatted', access = 'sequential', &
           action = 'write', iostat = ok)
      ! WRITE(lu, *) 'Xtarget     Ytarget     XActual    YActual'
      DO i = 1, npsi
        WRITE(lu, '(4(G0,3X))')  pattern(i)*COS(psi(i)), pattern(i)*SIN(psi(i)), syn(i)*COS(psi(i)), syn(i)*SIN(psi(i))
      ENDDO
      CLOSE(lu)

#endif

      DEALLOCATE(obs, pattern, psi, syn, y, delta)

    END SUBROUTINE scattering_pattern

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE solve_integral_multi(a, omega, epsabs, result, ok)

      ! Purpose:
      !   To compute the integral for the multiple scattering term, where "a" is lower limit of integration and "omega" the parameter
      !   in the integrand weighting function. "epsabs" controls integration accuracy
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),                               INTENT(IN)  :: a, omega, epsabs
      COMPLEX(r64),                            INTENT(OUT) :: result
      INTEGER(i32),                            INTENT(OUT) :: ok
      INTEGER(i32)                                         :: neval, ierr, lst
      INTEGER(i32),                  PARAMETER             :: limlst = 50, limit = 500, leniw = 2 * limit + limlst
      INTEGER(i32),                  PARAMETER             :: maxp1 = 21, lenw = leniw * 2 + maxp1 * 25
      INTEGER(i32), DIMENSION(leniw)                       :: iwork
      REAL(r64)                                            :: abserr, re, im
      REAL(r64),    DIMENSION(lenw)                        :: work

      !-----------------------------------------------------------------------------------------------------------------------------

      ok = 0

      ! solve for real part
      CALL dqawf (re_fun, a, omega, 2, epsabs, re, abserr, neval, ierr, limlst, lst, leniw, maxp1, lenw, iwork, work)

      ! solve for imaginary part
      CALL dqawf (im_fun, a, omega, 2, epsabs, im, abserr, neval, ierr, limlst, lst, leniw, maxp1, lenw, iwork, work)

      result = CMPLX(re, im, r64)

      IF (ierr .ne. 0) ok = 1

    END SUBROUTINE solve_integral_multi

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE fill_wigner()

      ! Purpose:
      !   To fill vector "wigner" with the sqaured values of Wigner 3j symbol (as in equation 8.104 of Sato et al., 2012) considering
      !   up to "lmax" degree in the spherical harmonics expansion of the scattering pattern function.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      INTERFACE wigner3j
        REAL(c_r64) FUNCTION gsl_sf_coupling_3j(ja, jb, jc, ma, mb, mc) bind(c)
          USE, INTRINSIC     :: iso_c_binding
          USE, NON_INTRINSIC :: m_precisions
          INTEGER(c_i32), VALUE :: ja, jb, jc, ma, mb, mc
        END FUNCTION gsl_sf_coupling_3j
      END INTERFACE wigner3j

      INTEGER(i32)   :: l, l1, l2, m, m1, m2, i, lprod
      INTEGER(c_i32) :: j1, j2, j3, n1, n2, n3
      REAL(r64)      :: w1, w2, sm

      !-----------------------------------------------------------------------------------------------------------------------------

      i = 0

      DO l1 = 0, lmax

        j3 = 2 * l1

        DO l = 0, lmax

          j1 = 2 * l

          DO l2 = 0, 2*lmax

            i = i + 1

            j2 = 2 * l2

            n1 = 0; n2 = 0; n3 = 0

            w2 = gsl_sf_coupling_3j(j1, j2, j3, n1, n2, n3)**2                !< second wigner3j

            ! set result directly to zero when "w2" is zero
            IF (w2 .eq. 0._r64) THEN
              wigner(i) = 0._r64
              CYCLE
            ENDIF

            lprod = (j1 + 1) * (j2 + 1) * (j3 + 1)

            sm = 0._r64

            DO m1 = -l1,l1

              n3 = 2 * m1

              DO m2 = -l2,l2

                n2 = 2 * m2

                m = m1 + m2

                n1 = -m * 2

                w1 = gsl_sf_coupling_3j(j1, j2, j3, n1, n2, n3)**2          !< first wigner3j

                sm = sm + w1 * w2

              ENDDO
            ENDDO

            wigner(i) = sm * 0.25_r64 * lprod / pi

          ENDDO
        ENDDO
      ENDDO

    END SUBROUTINE fill_wigner

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    REAL(r64) FUNCTION re_f0_m(k)

      ! Purpose:
      !   To compute the real part of equation 8.106a of Sato et al.(2012). This routine is called by QUADPACK quadrature scheme,
      !   where "k" is the main independent variable. Other variables needed to evaluate the function are access at module level.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),                          INTENT(IN) :: k
      COMPLEX(r64), DIMENSION((2*lmax+1))            :: glfun
      INTEGER(i32)                                   :: l

      !-----------------------------------------------------------------------------------------------------------------------------

      ! compute and store spherical Bessel functions
      DO l = 0, 2 * lmax
        glfun(l + 1) = gl(l, k)
      ENDDO

      ! first compute the f0 term of eq. 8.106a
      re_f0_m = REAL(f0(k, glfun), r64)

      ! add the last two terms
      ! re_f0_m = re_f0_m - REAL(f0_1(k, glfun), r64) - REAL(glfun(1), r64)
      re_f0_m = re_f0_m - REAL(glfun(1), r64)                               !< remove direct wave contribution

      ! multiply by k to complete kernel
      re_f0_m = re_f0_m * k

    END FUNCTION re_f0_m

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    REAL(r64) FUNCTION im_f0_m(k)

      ! Purpose:
      !   To compute the imaginary part of equation 8.106a of Sato et al.(2012). This routine is called by QUADPACK quadrature scheme,
      !   where "k" is the main independent variable. Other variables needed to evaluate the function are access at module level.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),                          INTENT(IN) :: k
      COMPLEX(r64), DIMENSION((2*lmax+1))            :: glfun
      INTEGER(i32)                                   :: l

      !-----------------------------------------------------------------------------------------------------------------------------

      ! compute and store spherical Bessel functions
      DO l = 0, 2 * lmax
        glfun(l + 1) = gl(l, k)
      ENDDO

      ! first compute the f0 term of eq. 8.106a
      im_f0_m = AIMAG(f0(k, glfun))

      ! add the last two terms
      ! im_f0_m = im_f0_m - AIMAG(f0_1(k, glfun)) - AIMAG(glfun(1))
      im_f0_m = im_f0_m - AIMAG(glfun(1))                                    !< remove direct wave contribution

      ! multiply by k to complete kernel
      im_f0_m = im_f0_m * k

    END FUNCTION im_f0_m

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    COMPLEX(r64) FUNCTION f0(k, glfun)

      ! Purpose:
      !   To evaluate the set of linear equations described by eq. 8.104 of Sato et al.(2012) and return the lowest degree term (f0).
      !   The original equation has been rearranged for faster execution. This routine is called from inside the QUADPACK quadrature
      !   scheme.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),                                       INTENT(IN) :: k
      COMPLEX(r64), DIMENSION(2*lmax+1),               INTENT(IN) :: glfun
      COMPLEX(r64)                                                :: sm, fact
      COMPLEX(r64),                          PARAMETER            :: zero = CMPLX(0._r64, 0._r64, r64)
      COMPLEX(r64),                          PARAMETER            :: zeta = CMPLX(0._r64, 1._r64, r64)
      COMPLEX(r64), DIMENSION(lmax+1)                             :: b
      COMPLEX(r64), DIMENSION(lmax+1,lmax+1)                      :: a
      INTEGER(i32)                                                :: l, l1, l2, i, n, ok
      INTEGER(i32), DIMENSION(lmax+1)                             :: ipiv
      REAL(r64)                                                   :: c, c1

      !-----------------------------------------------------------------------------------------------------------------------------

      ! number of harmonics
      n = lmax + 1

      i = 0

      ! set up the system of linear equations to find f0
      DO l1 = 0, lmax

        c1 = SQRT(4._r64 * pi / (2 * l1 + 1._r64)) * coef(l1 + 1)

        DO l = 0, lmax

          c = c1 * beta / (2 * l + 1._r64)

          sm = zero

          DO l2 = 0, 2*lmax

            i = i + 1

            fact = zeta**(l1 + l2 - l)                                     !< must be real for non-zero "sm" terms below

            sm = sm + fact * glfun(l2 + 1) * wigner(i)

          ENDDO

          a(l + 1, l1 + 1) = c * sm

       ENDDO

      ENDDO

      ! prepare matrix for inversion
      DO i = 1, n
        a(i, i) = a(i, i) - 1._r64
      ENDDO

      ! define r.h.s. vector
      DO i = 1, n
        b(i) = -glfun(i)
      ENDDO

      ! solve linear system a*x = b
      CALL zgesv(n, 1, a, n, ipiv, b, n, ok)

      ! take first element
      f0 = b(1)

    END FUNCTION f0

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    COMPLEX(r64) FUNCTION gl(l, k)

      ! Purpose:
      !   To compute the spherical Bessel function of degree "l" (eq. 8.66 of Sato et al., 2012). This routine is called from inside
      !   the QUADPACK quadrature scheme.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      INTEGER(i32),           INTENT(IN) :: l
      REAL(r64),              INTENT(IN) :: k
      COMPLEX(r64)                       :: kw, wk, kw2, gd, a, b, c, hyp_2f1
      ! COMPLEX(r64), PARAMETER            :: zeta = CMPLX(0._r64, 1._r64, r64)
      ! COMPLEX(r64), PARAMETER            :: zeta_half = CMPLX(0._r64, 0.5_r64, r64)

      !-----------------------------------------------------------------------------------------------------------------------------

      kw = k / wgs
      wk = wgs / k

      ! use expansion with Gauss hypergeometric function
      IF (l .ge. 2) THEN

        a = CMPLX((l + 1) / 2._r64, 0._r64, r64)
        b = CMPLX((l + 2) / 2._r64, 0._r64, r64)
        c = CMPLX((l + 1.5_r64),    0._r64, r64)

        kw2 = -kw * kw

        gd = (kw / 2._r64)**(l + 1) * gammal(l - 1) * hyp_2f1(a, b, c, kw2)

      ELSE IF (l .eq. 0) THEN

        gd = ATAN(kw)
        ! gd = zeta_half * LOG( (1._r64 - zeta*kw) / (1._r64 + zeta*kw) )

      ELSE IF (l .eq. 1) THEN

        gd = (1._r64 - wk * ATAN(kw))
        ! gd = (1._r64 - wk * zeta_half * LOG( (1._64 - zeta*kw) / (1._64 + zeta*kw) ))

      ENDIF

      gl = gd / k / beta

      gl = gl * ms

    END FUNCTION gl

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    COMPLEX(r64) FUNCTION f0_1(k, glfun)

      ! Purpose:
      !   To compute the f0_1 term of eq. 8.106 based on eq. 8.107 in Sato et al.(2012). This routine is called from inside the
      !   QUADPACK quadrature scheme.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),                                   INTENT(IN) :: k
      COMPLEX(r64), DIMENSION(2*lmax+1),           INTENT(IN) :: glfun
      COMPLEX(r64),                      PARAMETER            :: zero = CMPLX(0._r64, 0._r64, r64)
      INTEGER(i32)                                            :: l

      !-----------------------------------------------------------------------------------------------------------------------------

      f0_1 = zero

      ! sum contributions over degrees
      DO l = 0, lmax
        f0_1 = f0_1 + (-1._r64)**l * SQRT(pi + 2 * l * pi) * coef(l + 1) * glfun(l + 1)**2
      ENDDO

      ! normalise result
      f0_1 = f0_1 * beta / (2._r64 * pi)

    END FUNCTION f0_1

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE solve_integral_single(result, ok)

      ! Purpose:
      !   To compute the integral for the multiple scattering term, where "a" is lower limit of integration and "omega" the parameter
      !   in the integrand weighting function.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),                               INTENT(OUT) :: result
      INTEGER(i32),                            INTENT(OUT) :: ok
      INTEGER(i32)                                         :: neval, ierr, last
      INTEGER(i32),                  PARAMETER             :: limit = 500, lenw = limit * 4
      INTEGER(i32), DIMENSION(limit)                       :: iwork
      REAL(r64)                                            :: abserr
      REAL(r64),                     PARAMETER             :: epsabs = 0._r64, epsrel = 1.e-06_r64
      REAL(r64),    DIMENSION(lenw)                        :: work

      !-----------------------------------------------------------------------------------------------------------------------------

      ok = 0

      CALL dqng(sfun, -1._r64, 1._r64, epsabs, epsrel, result, abserr, neval, ierr)
      ! CALL dqaf (sfun, -1._r64, 1._r64, epsabs, epsrel, 2, result, abserr, neval, ierr, limit, lenw, last, iwork, work)

      IF (ierr .ne. 0) ok = 1

    END SUBROUTINE solve_integral_single

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    REAL(r64) FUNCTION sfun(w)

      ! Purpose:
      !   To evaluate the integrand of the single-scattering equation 8.108 in Sato et al.(2012). This routine is called from inside
      !   the QUADPACK quadrature scheme.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !

      REAL(r64),     INTENT(IN) :: w
      INTEGER(c_i32)            :: l
      INTEGER(c_i32), PARAMETER :: m = 0
      REAL(c_r64)               :: x
      REAL(r64)                 :: wsquared, vw

      !-----------------------------------------------------------------------------------------------------------------------------

      wsquared = w**2

      vw = vsquared - wsquared

      ! compute cos of angle psi (as defined in eq. 3.17)
      x = (2._r64 - vsquared - wsquared) / vw

      sfun = 0._r64

      ! synthesize angle-dependent scattering coefficient
      DO l = 0, lmax
        sfun = sfun + legendre_sphplm(l, m, x) * coef(l + 1)
      ENDDO

      sfun = sfun / vw

    END FUNCTION sfun

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

#ifdef MPI
    SUBROUTINE rtt_isotropic(comm, pprank, time, tp, ts, eta_pp, eta_ps, eta_sp, eta_ss, eta_si, vs, wp, ws, tau, envelope, ok)
#else
    SUBROUTINE rtt_isotropic(time, tp, ts, eta_pp, eta_ps, eta_sp, eta_ss, eta_si, vs, wp, ws, tau, envelope, ok)
#endif

      ! Purpose:
      !   To return the envelope resulting from multiple scattering of P- and S-waves generated by an impulsive source embedded in
      !   unbounded heterogeneous media having background velocity "vs". Conversion from one wave type to the other is controlled by
      !   scattering parameters "eta_pp", "eta_ps", "eta_sp", "eta_ss" (omega/2/Qxx). Intrinsic attenuation is expressed by "eta_si"
      !   (omega/2/Qi). The routine computes an "envelope" defined at "time", whereas the direct P- and S-wave arrival-time is "tp"
      !   and "ts", respectively. The P/S energy at the source is given by "wp" and "ws". The envelope is normalized to 1 if "scaling"
      !   is set to true.
      !
      !   The underlying algorithm makes the following assumptions:
      !     2) b = vp * eta_pi = vs * eta_si
      !     3) alpha * tp = beta * ts
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   29/03/19                  original version
      !   02/09/20
      !

#ifdef MPI
      INTEGER(i32),                         INTENT(IN)  :: comm
      INTEGER(i32), DIMENSION(:),           INTENT(IN)  :: pprank
#endif
      REAL(r32),    DIMENSION(:),           INTENT(IN)  :: time
      REAL(r32),                            INTENT(IN)  :: tp, ts, eta_pp, eta_ps, eta_sp, eta_ss, eta_si, vs, wp, ws, tau
      REAL(r32),    DIMENSION(SIZE(time)),  INTENT(OUT) :: envelope
      INTEGER(i32),                         INTENT(OUT) :: ok
      COMPLEX(r64), DIMENSION(nfft/2+1)                 :: spectrum
      INTEGER(i32)                                      :: i, is, ip, lu, i0, i1, ierr, rank
      INTEGER(i32)                                      :: nwigner, npts
#ifdef MPI
      INTEGER(i32), DIMENSION(SIZE(pprank))             :: displs
#endif
      REAL(r32)                                         :: amin
      REAL(r64)                                         :: t, dt, sr, tcalc, c0, eta, eta_s, eta_p, epp, eps, ess, esp
      REAL(r64)                                         :: w, dw, wi, epsabs, re, im, kmin, wcut, v, ratio, b
      REAL(r64),    DIMENSION(2)                        :: a
      REAL(r64),    DIMENSION(4)                        :: tictoc
      REAL(r64),    DIMENSION(nfft)                     :: e_multi, e_time
      REAL(r64),    DIMENSION(SIZE(time))               :: e0, e1, em, dtime

      !-----------------------------------------------------------------------------------------------------------------------------

      ok = 0

#ifdef MPI
      CALL mpi_comm_rank(comm, rank, ierr)

      rank = rank + 1
#endif

      CALL watch_start(tictoc(1))

      ! assign input parameters to global variables
      e0_p  = wp
      e0_s  = ws
      beta  = vs
      alpha = beta * ts / tp

      ! total scattering
      eta_s = eta_ss + eta_sp
      eta_p = eta_pp + eta_ps

      npts = SIZE(time)

      ! define maximum time for m-th term energy envelope calculation
      tcalc = time(npts) * (1._r64 + time_factor / 100._r64)

      ! equivalent source-receiver distance
      sr = beta * ts

      ! evaluate paaschens' heuristic solution for multiple isotropic scattering at S-wave arrival time and maximum time
      CALL paasschens([REAL(ts, r64), tcalc], REAL(ts, r64), beta, real(eta_ss,r64), 0._r64, a)

      ! estimate imaginary shift: because of the periodicity introduced by the wavenumber summation, energy "a(2)" at time "tmax"
      ! (which will be aliased in time) must be much smaller than energy "a(1)", i.e. "a(2)*exp(-wi*tcalc) << a(1)". This condition
      ! can be set as "a(1)*exp(wi*tcalc) = 500*a(2)" or "wi = ln(large_number*a(2)/a(1)) / tcalc".
      ! wi = LOG(500._r64 * a(2) / a(1)) / tcalc
      wi = LOG(1.e+05_r64 * a(2) / a(1)) / tcalc

      ! set absolute accuracy for numerical integration. Divide by 100 to set relative accuracy to 10^-3
      epsabs = MAX(MIN(a(1), a(2)) / 1000._r64, EPSILON(1._r64))

      ! define minimum wavenumber for integration (kmin << pi / L, eq. 4.125 of Jensen et al., 2011)
      kmin = pi / (alpha * tcalc + sr) / 5._r64

      ! time resolution of multiple scattering envelope
      dt = tcalc / nfft

      ! angular frequency resolution
      dw = 2.0 * pi / nfft / dt

      ! normalise scattering coefficients
      veta_pp = eta_pp * alpha
      veta_ps = eta_ps * alpha
      veta_ss = eta_ss * beta
      veta_sp = eta_sp * beta

      ! select functions for integration
      re_fun => re_gsgp
      im_fun => im_gsgp

      i0 = 1
      i1 = nfft/2 + 1

#ifdef MPI
      displs(1) = 0

      DO i = 2, SIZE(pprank)
        displs(i) = displs(i - 1) + pprank(i - 1)
      ENDDO

      i0 = displs(rank) + 1
      i1 = i0 + pprank(rank) - 1
#endif

      CALL watch_start(tictoc(2))

      !$omp parallel do default(shared) private(i, w) reduction(max: ok)
      DO i = i0, i1

        w = dw * (i - 1)

        ! complex frequency, including imaginary shift
        wgp = CMPLX(eta_p + wi/alpha, w/alpha, r64)
        wgs = CMPLX(eta_s + wi/beta, w/beta, r64)

        ! smoothing wavelet
        ms = EXP(-tau**2 * w**2 / 16._r64)
        ! IF (w .eq. 0._r64) THEN
        !   ms = CMPLX(1._r64, 0._r64)
        ! ELSE
        !   ms = 2._r64 * CMPLX(COS(pi*0.25_r64), -SIN(pi*0.25_r64)) * SQRT(tau * w)
        !   ms = ms / SIN(ms)
        ! ENDIF

        ! solve integral for multiple scattering term at i-th frequency
        CALL solve_integral_multi(kmin, sr, epsabs, spectrum(i), ok)

      ENDDO
      !$omp end parallel do

      CALL watch_stop(tictoc(2))

#ifdef MPI
      ! exchange data inside communicator
      CALL mpi_allgatherv(mpi_in_place, 0, mpi_datatype_null, spectrum, pprank, displs, mpi_double_complex, comm, ierr)
#endif

      CALL watch_start(tictoc(3))

      CALL make_fftw_plan([nfft])
      CALL ifft(e_multi, spectrum)
      CALL destroy_fftw_plan([nfft])

      ! scaling factor for m-th order scattering
      c0 = 0.5_r64 / (sr * pi**2) / dt

      ! ip = NINT(tp / dt) + 1
      ! e_multi(1:ip) = 0._r64

      ! compensate for imaginary frequency "wi" and add scaling factor
      DO i = 1, nfft
        e_multi(i) = e_multi(i) * EXP(wi * (i - 1) * dt) * c0
        e_time(i) = (i - 1) * dt
      ENDDO

      CALL setup_interpolation('linear', 'zero', ok)

      dtime = time

      CALL interpolate(e_time, e_multi, dtime, em)

      CALL watch_stop(tictoc(3))

      ! now "dt" is the actual output time-step
      dt = time(2) - time(1)

      em(1:NINT(tp / dt)) = 0._r64                         !< mute all points up to direct P because of numerical noise

      ! ============================================================================================================================
      ! -------------------------------------------------- DIRECT WAVE TERM --------------------------------------------------------
      ! ============================================================================================================================

      e0(:) = 0._r64

      ! scaling factor
      c0 = 0.5_r64 / (pi * SQRT(pi) * tau * sr**2)

      v  = e0_p * c0 * EXP(-eta_p * alpha * tp) / alpha
      b  = e0_s * c0 * EXP(-eta_s * beta * ts) / beta
      c0 = 4._r64 / tau**2

      DO i = 1, npts
        e0(i) = e0(i) + v * EXP(-c0 * (time(i) - tp)**2)
        e0(i) = e0(i) + b * EXP(-c0 * (time(i) - ts)**2)
      ENDDO



      ! e0(:)  = 0._r64
      ! e1(:)  = 0._r64
      !
      ! is = NINT(ts / dt) + 1
      !
      ! ip = 1
      !
      ! DO
      !
      !   epsabs = 0._r64
      !   b      = 0._r64
      !
      !   DO i = is + 1, npts
      !     e0(i)  = e0(i) + (-1)**(ip + 1) * ip**2 * EXP(-ip**2 * pi**2 * (time(i) - ts) * 0.25_r64 / tau)
      !     epsabs = MAX(epsabs, ABS(e0(i)-e1(i)))
      !     b      = MAX(b, ABS(e0(i)))
      !     e1(i)  = e0(i)
      !   ENDDO
      !
      !   IF (epsabs / b .lt. 1.e-07_r64) EXIT
      !
      !   ip = ip + 1
      !
      ! ENDDO
      !
      ! c0 = e0_s * 0.25_r64 * pi / (sr**2 * 2._r64 * tau) * EXP(-eta_s * beta *ts)
      !
      ! DO i = 1, npts
      !   e0(i) = c0 * e0(i)
      ! ENDDO



      ! e0(:) = 0._r64
      !
      ! ip = NINT(tp / dt) + 1
      ! is = NINT(ts / dt) + 1
      !
      ! ! scaling factor
      ! c0 = 0.25_r64 / (pi * sr**2)
      !
      ! e0(ip) = e0_p * c0 * EXP(-eta_p * alpha * tp) / alpha
      ! e0(is) = e0_s * c0 * EXP(-eta_s * beta * ts) / beta
      !
      ! ! ============================================================================================================================
      ! ! ----------------------------------------------- SINGLE SCATTERING TERM -----------------------------------------------------
      ! ! ============================================================================================================================
      !
      ! e1(:) = 0._r64
      !
      ! ratio = alpha / beta
      !
      ! ! eta = (eta_ss + eta_sp)*beta = (eta_pp + eta_ps)*alpha (see assumption 1 and 2)
      ! eta = eta_s * beta
      !
      ! DO i = ip + 1, npts
      !
      !   t = time(i)
      !
      !   eps = 0._r64
      !   esp = 0._r64
      !   epp = 0._r64
      !   ess = 0._r64
      !
      !   v = alpha * t / sr
      !
      !   ! eq. 8.56a and 8.56b
      !   IF (i .lt. is) THEN
      !     eps = e0_p * ratio * eta_ps * 0.5_r64 / v * LOG( (ratio + v) / (ratio - v) ) * EXP(-eta * t)
      !     esp = e0_s * eta_sp * 0.5_r64 / v * LOG( (ratio + v) / (ratio - v) ) * EXP(-eta * t)
      !   ELSEIF (i .gt. is) THEN
      !     eps = e0_p * ratio * eta_ps * 0.5_r64 / v * LOG( (v + 1._r64) * (ratio + v) / (v - 1._r64) / (v - ratio) ) * EXP(-eta * t)
      !     esp = e0_s * eta_sp * 0.5_r64 / v * LOG( (v + 1._r64) * (ratio + v) / (v - 1._r64) / (v - ratio) ) * EXP(-eta * t)
      !   ENDIF
      !
      !   eps = eps * c0
      !   esp = esp * c0
      !
      !   ! eq. 8.56c
      !   epp = e0_p * eta_pp / v * LOG( (v + 1._r64) / (v - 1._r64) ) * EXP(-eta * t)
      !   epp = epp * c0
      !
      !   v = beta * t / sr
      !
      !   ! eq. 8.56d
      !   IF (i .gt. is) ess = e0_s * eta_ss / v * LOG( (v + 1._r64) / (v - 1._r64) ) * EXP(-eta * t)
      !
      !   ess = ess * c0
      !
      !   e1(i) = e1(i) + epp + eps + esp + ess
      !
      ! ENDDO

      ! ============================================================================================================================
      ! --------------------------------------------- ADD INTRINSIC ATTENUATION ----------------------------------------------------
      ! ============================================================================================================================

      ! see also assumption 2
      b = eta_si * beta
      ! amin = HUGE(1._r32)
      DO i = 1, npts
        ! envelope(i) = (e0(i) + e1(i) + em(i)) * EXP(-b * time(i))
        envelope(i) = (e0(i) + em(i)) * EXP(-b * time(i))
        ! amin = MIN(ABS(envelope(i)), amin)
      ENDDO

      ! replace negative values due to numerical errors: this is somewhat redundant
      ! WHERE (envelope .lt. amin)
      !   envelope = amin
      ! END WHERE

      CALL watch_stop(tictoc(1))

#ifdef DEBUG

      OPEN(newunit = lu, file = 'rtt_isotropic.txt', status = 'unknown', form = 'formatted', access = 'sequential', &
           action = 'write', iostat = ok)
      ! WRITE(lu, *) ' Time    Direct wave   Single order   Higher order    Total'
      DO i = 1, npts
        WRITE(lu, '(5(G0, 3X))') time(i), e0(i), em(i), envelope(i)
      ENDDO
      CLOSE(lu)

      WRITE(stdout, '(A)') '                     Total  |  Integration  |   FFT/interp  |'
      WRITE(stdout, '(A,3(ES14.3,A))') 'Elapsed time:', tictoc(1), ' |', tictoc(2), ' |', tictoc(3), ' |'

#endif

    END SUBROUTINE rtt_isotropic

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    REAL(r64) FUNCTION re_gsgp(k)

      REAL(r64), INTENT(IN) :: k

      !-----------------------------------------------------------------------------------------------------------------------------

      re_gsgp = REAL(gsgp(k), r64) * k

    END FUNCTION re_gsgp

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    REAL(r64) FUNCTION im_gsgp(k)

      REAL(r64), INTENT(IN) :: k

      !-----------------------------------------------------------------------------------------------------------------------------

      im_gsgp = AIMAG(gsgp(k)) * k

    END FUNCTION im_gsgp

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    COMPLEX(r64) FUNCTION gsgp(k)

      REAL(r64),   INTENT(IN) :: k
      COMPLEX(r64)            :: gp, gs, kw

      !-----------------------------------------------------------------------------------------------------------------------------

      ! eq. 8.46
      kw = k / wgp
      gp = ATAN(kw) / k / alpha

      kw = k / wgs
      gs = ATAN(kw) / k / beta

      !
      gp = gp * ms
      gs = gs * ms
      !

      ! evaluate eq. 8.51c without denominator
      ! gsgp = e0_p * gp * ( gs*veta_ps * (gs*veta_ss*(1._r64 - gp*veta_pp) + gp*veta_sp*(1._r64 + gs*veta_ps))      +   &
      !                      gp*veta_pp * (gp*veta_pp*(1._r64 - gs*veta_ss) + gs*veta_ps*(1._r64 + gp*veta_sp)) )    +   &
      !        e0_s * gs * ( gp*veta_sp * (gp*veta_pp*(1._r64 - gs*veta_ss) + gs*veta_ps*(1._r64 + gp*veta_sp))      +   &
      !                      gs*veta_ss * (gs*veta_ss*(1._r64 - gp*veta_pp) + gp*veta_sp*(1._r64 + gs*veta_ps)) )
      !
      ! ! now plug-in denominator
      ! gsgp = gsgp / ( (1._r64 - gp*veta_pp) * (1._r64 - gs*veta_ss) - veta_sp*veta_ps*gp*gs )


      gsgp = e0_p * gp * (1._r64 - veta_ss * gs) + e0_s * gs * veta_sp * gp    +  &
             e0_s * gs * (1._r64 - veta_pp * gp) + e0_p * gp * veta_ps * gs

      gsgp = gsgp / ( (1._r64 - gp*veta_pp) * (1._r64 - gs*veta_ss) - veta_sp * veta_ps * gp * gs )

      gsgp = gsgp - e0_p * gp - e0_s * gs                       !< remove direct wave energy

    END FUNCTION gsgp

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE paasschens(time, ts, beta, eta, eta_i, envelope)

      ! Purpose:
      !   To return Paasschens heuristic solution to the 3D radiative transfer equation for isotropic multiple scattering. Error is
      !   known to be less than 5%, except around direct wave arrival time.
      !   Used formula may fail when ts < time < ts + eps, where eps is a small number. In this unlikely case, uncomment lines below.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   04/05/20                  original version
      !

      REAL(r64),   DIMENSION(:),                    INTENT(IN)  :: time
      REAL(r64),                                    INTENT(IN)  :: ts, beta, eta, eta_i
      REAL(r64),   DIMENSION(SIZE(time)),           INTENT(OUT) :: envelope
      INTEGER(i32)                                              :: i, is, i0, lu, ok
      REAL(r64)                                                 :: vt, f, x, eps, dt, b
      REAL(r64),                          PARAMETER             :: tol = 1.e-06_r64, c0 = 4.18879020478639_r64

      !-----------------------------------------------------------------------------------------------------------------------------

      envelope(:) = 0._r64

      dt = time(2) - time(1)

      i0 = NINT((ts - time(1)) / dt) + 1                                                   !< index S-wave arrival time

      is = i0

      vt = beta * ts

      b = eta_i * beta

      envelope(is) = EXP(-eta * vt) * 0.25_r64 / (beta * pi * vt**2) * EXP(-b * ts)        !< direct wave

      ! Paasschens formula may fail when "time" and "ts" are very close. Make sure points where this happens are skipped.
      ! eps = ABS(time(is + 1) - ts)
      !
      ! DO WHILE (eps .le. tol)
      !   is = is + 1
      !   eps = ABS(time(is + 1) - ts)
      ! ENDDO

      DO i = is + 1, SIZE(time)

        f = 1._r64 - (ts / time(i))**2

        vt = beta * time(i)

        x = eta * vt * f**(0.75_r64)

        envelope(i) = EXP(-eta * vt) * EXP(x) * SQRT(1._r64 + 2.026_r64 / x) * f**(1._r64 / 8._r64) / (c0 * vt / eta)**1.5_r64

        envelope(i) = envelope(i) * EXP(-b * time(i))

      ENDDO

      ! interpolate those points where formula may fail
      ! CALL setup_interpolation('linear', 'zero', ok)
      !
      ! DO i = i0 + 1, is
      !   CALL interpolate(time(i0:is + 1), envelope(i0:is + 1), time(i), envelope(i))
      ! ENDDO

#ifdef DEBUG

      OPEN(newunit = lu, file = 'rtt_paasschens.txt', status = 'unknown', form = 'formatted', access = 'sequential', &
           action = 'write', iostat = ok)
      ! WRITE(lu, *) ' Time    Envelope'
      DO i = 1, SIZE(time)
        WRITE(lu, '(2(G0, 3X))') time(i), envelope(i)
      ENDDO
      CLOSE(lu)

#endif

    END SUBROUTINE paasschens

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE watch_start(tictoc, comm)

      ! Purpose:
      !   To start the stopwatch. Timing is in double-precision. For MPI, if specific communicator handle not given, mpi_comm_world
      !   is used.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   04/05/20                  original version
      !

      REAL(r64),              INTENT(OUT) :: tictoc                            !< initial time
      INTEGER(i32), OPTIONAL, INTENT(IN)  :: comm                              !< communicator handle
      INTEGER(i32)                        :: count, rate, ierr

      !-----------------------------------------------------------------------------------------------------------------------------

#ifdef MPI

      IF (.NOT.PRESENT(comm)) THEN
        CALL mpi_barrier(mpi_comm_world, ierr)
      ELSE
        CALL mpi_barrier(comm, ierr)
      ENDIF

      tictoc = mpi_wtime()

#else

      CALL system_clock(count, rate)

      tictoc = REAL(count, r64) / REAL(rate, r64)

#endif

    END SUBROUTINE watch_start

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    SUBROUTINE watch_stop(tictoc, comm)

      ! Purpose:
      !   To stop the stopwatch and return the elapsed time. Timing is in double-precision. For MPI, if specific communicator handle
      !   not given, mpi_comm_world is used.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   04/05/20                  original version
      !

      REAL(r64),              INTENT(INOUT) :: tictoc                          !< elapsed time
      INTEGER(i32), OPTIONAL, INTENT(IN)    :: comm                            !< communicator handle
      INTEGER(i32)                          :: count, rate, ierr

      !-----------------------------------------------------------------------------------------------------------------------------

#ifdef MPI

      IF (.NOT.PRESENT(comm)) THEN
        CALL mpi_barrier(mpi_comm_world, ierr)
      ELSE
        CALL mpi_barrier(comm, ierr)
      ENDIF

      tictoc = mpi_wtime() - tictoc

#else

      CALL system_clock(count, rate)

      tictoc = REAL(count, r64) / REAL(rate, r64) - tictoc

#endif

    END SUBROUTINE watch_stop

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    REAL(r64) FUNCTION rms(r)

      ! Purpose:
      !   To compute the root-mean-square of input vector "r" based on the compensated-summation version of the two-pass algorithm.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   04/05/20                  original version
      !

      REAL(r64),   DIMENSION(:), INTENT(IN) :: r
      INTEGER(i32)                          :: i, n
      REAL(r64)                             :: mu, s1, s2, x, v, c

      !---------------------------------------------------------------------------------------------------------------------------

      n = SIZE(r)

      ! compute mean
      mu = 0._r64
      v  = 1._r64

      DO i = 1, n
        mu = mu + (r(i) - mu) / v
        v  = v + 1._r64
      ENDDO

      ! compute variance
      s1 = 0._r64
      s2 = 0._r64

      DO i = 1, n
        x = r(i) - mu
        s1 = s1 + x
        s2 = s2 + x**2
      ENDDO

      s1 = (s1**2) / n

      v = (s2 - s1) / (n - 1)

      rms = SQRT(v + mu**2)

    END FUNCTION rms

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    INTEGER(i32) FUNCTION query_fft_size()

      ! Purpose:
      !   to return half the number of points for calculations in the frequency domain.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   11/01/21                  original version
      !

      query_fft_size = (nfft / 2) + 1

    END FUNCTION query_fft_size

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

    FUNCTION rtt_error(ierr) RESULT(msg)

      ! Purpose:
      !   to translate an error code into a text for all routines in current module.
      !
      ! Revisions:
      !     Date                    Description of change
      !     ====                    =====================
      !   02/09/20                  original version
      !

      INTEGER(i32),  INTENT(IN) :: ierr
      CHARACTER(100)            :: msg

      !-----------------------------------------------------------------------------------------------------------------------------

      SELECT CASE(ierr)
      CASE(1)
        msg = 'Runtime error in scattering_pattern: llsq_solver failed'

      CASE(2)
        msg = 'Runtime error in scattering_pattern: could not converge to desired scattering pattern'

      ! CASE(3)
      !   msg = 'IO error in read_miniseed: sampling interval not found'
      !
      ! CASE(4)
      !   msg = 'IO error in read_miniseed: error while reading file'
      !
      ! CASE(5)
      !   msg = 'IO error in read_miniseed: could not close file'
      !
      ! CASE(6)
      !   msg = 'IO error in recurrences: error while reading file'
      !
      ! CASE(7)
      !   msg = 'IO error in parse (parse_char): error while reading file'
      !
      ! CASE(8)
      !   msg = 'error in parse (parse_int_mat): string-to-integer conversion error'
      !
      ! CASE(9)
      !   msg = 'error in parse (parse_real_mat): string-to-real conversion error'

      END SELECT


    END FUNCTION rtt_error

    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *
    !===============================================================================================================================
    ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- *

END MODULE m_rtt
